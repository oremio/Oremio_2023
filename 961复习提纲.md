# 961复习提纲

使用教辅：王道四件套、天勤四件套

注：难题、综合题要及时加入改错本，并做足注释！！

## <a name="index">**目录**</a>

&emsp;<a href="#1">2023年硕士研究生入学考试专业课961考研大纲</a>  
&emsp;<a href="#2">复习提纲</a>  
&emsp;<a href="#3">计算机组成原理（60分）</a>  
&emsp;&emsp;<a href="#4">（一）计算机系统概述</a>  
&emsp;&emsp;<a href="#5">（二）数据的表示和运算</a>  
&emsp;&emsp;<a href="#6">（三）存储器层次结构</a>  
&emsp;&emsp;<a href="#7">（四）MIPS指令系统及汇编语言</a>  
&emsp;&emsp;<a href="#8">（五）MIPS处理器</a>  
&emsp;&emsp;<a href="#9">（六）总线与输入输出(I/O)系统</a>  
&emsp;<a href="#10">操作系统（50分）</a>  
&emsp;&emsp;<a href="#11">（一）操作系统概述</a>  
&emsp;&emsp;<a href="#12">（二）进程管理</a>  
&emsp;&emsp;<a href="#13">（三）内存管理</a>  
&emsp;&emsp;<a href="#14">（四）设备管理</a>  
&emsp;&emsp;<a href="#15">（五）文件系统</a> 
&emsp;<a href="#16">计算机网络（40分）</a>  
&emsp;&emsp;<a href="#17">（一）计算机网络概述</a>  
&emsp;&emsp;<a href="#18">（二）物理层</a>  
&emsp;&emsp;<a href="#19">（三）数据链路层</a>  
&emsp;&emsp;<a href="#20">（四）网络层</a>  
&emsp;&emsp;<a href="#21">（五）传输层</a>  
&emsp;&emsp;<a href="#22">（六）应用层</a>  
&emsp;<a href="#23">附录：各种名词缩写及含义</a>  

## <a name="1">2023年硕士研究生入学考试专业课961考研大纲</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>
一、考试组成

961计算机基础综合共包括三门课程的内容：计算机组成原理、操作系统、计算机网络技术，分别占60分，50分、40分。所有课程均不指定参考书。

二、计算机组成原理部分的考试大纲（60分）

<一>、整体要求

（一）理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有完整的计算机系统的整机概念；

（二）理解计算机系统层次化结构概念，掌握以MIPS为代表的RISC指令集体系结构的基本知识，能对MIPS汇编程序设计语言的相关问题进行分析；

（三）理解计算机存储系统的层次化结构，掌握层次化存储系统的设计、分析和性能计算；

（四）能根据指令语义进行单周期、多周期或流水线MIPS处理器的数据通路及其控制器的分析和简单设计；

（五）理解并掌握输入输出系统的基本知识。

<二>、知识要点

（一）计算机系统概述

（1）计算机系统的基本组成与层次结构

（2）计算机系统的性能指标：吞吐量、响应时间、带宽、延迟；CPU时钟周期、主频、CPI、CPU执行时间；MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS。

（二）数据的表示和运算

（1）数制与编码

（2）定点数和浮点数的表示和运算

（3）算术逻辑单元ALU

1）串行加法器和并行加法器

2）算术逻辑单元ALU的功能和结构

（三）存储器层次结构

（1）存储器的层次化结构

（2）主存储器与CPU的连接

（3）高速缓冲存储器(Cache)

1）Cache的基本工作原理

2）Cach和主存之间的映射方式

3）Cache中主存块的替换算法与写策略

4）多层次Cache性能计算

（4）虚拟存储器

1）虚拟存储器的基本概念

2）页式虚拟存储器

3）TLB(快表)

（四）MIPS指令系统及汇编语言

（1）指令系统的基本知识（指令格式、寻址方式）

（2）MIPS汇编语言

（五）MIPS处理器

（1）CPU的功能和基本结构

（2）单周期、多周期MIPS处理器数据通路的功能和基本结构

（3）硬布线控制器的功能和工作原理

1）单周期处理器控制器

2）多周期处理器控制器

（4）指令流水线

1）指令流水线的基本概念

2）流水线冒险及处理策略

3）指令流水线的基本实现

（六）总线与输入输出(I/O)系统

（1）总线的基本概念

（2）磁盘存储器

（3）I/O控制器

1）I/O控制器的功能和基本结构

2）存储映射I/O编址

（4）基本I/O方式

1）程序查询方式

2）程序中断方式：中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念；

3）DMA方式，DMA控制器组成，DMA传送过程，设备传输性能计算。

三、操作系统部分的考试大纲（50分）

（一） 可参考书目

1.操作系统实用教程（第三版），任爱华，清华大学出版社。

2.现代操作系统(Modern Operating System) (The 3rd Edition),陈向群,马洪兵等译,Andrew S. Tanenbaum著,机械工业出版社。

（二） 复习内容

1.操作系统概述

a)操作系统的基本概念；内核态与用户态、中断、异常和系统调用。

2.进程管理

a)进程、线程的基本概念以及两者的区别；

b)进程控制块、进程的状态与转换；

c)进程同步的基本概念；实现临界区互斥的基本方法；信号量机制及P、V操作；了解经典同步问题，并通过信号量机制解决进程同步问题。

d)进程间通信，包括共享存储系统、消息传递系统、管道。

e)进程调度的基本准则；典型调度算法：先来先服务调度算法、短作业(短进程、短线程)优先调度算法、时间片轮转调度算法、优先级调度算法。

f)死锁的形成原因与必要条件；死锁预防、死锁避免、死锁检测和解除。

3.内存管理

a)程序装入与链接；逻辑地址与物理地址空间；重定位；内存保护。

b)分区管理；交换与覆盖技术；

c)分页管理方式；分段管理方式；段页式管理方式。

d)虚拟内存基本概念和局部性原理；缺页中断；地址变换过程；

e)页面置换算法：最佳置换算法(OPT)、先进先出置换算法(FIFO)、最近最少使用置换算法(LRU)、时钟置换算法(CLOCK)；工作集模型。

4.设备管理

a) I/O控制方式：程序控制、中断、DMA、通道；缓冲技术；假脱机技术(SPOOLing)。

5.文件系统

a)文件与文件系统的基本概念；组织方式；文件控制块；目录结构；文件存取控制；文件系统层次结构。

b）磁盘的结构；磁盘调度算法；廉价冗余磁盘阵列。

四、计算机网络部分的考试大纲（40分）

（一）可参考书目《计算机网络》(第8版)，谢希仁编著，电子工业出版社，2021

（二）复习内容

1、计算机网络概述

(1)计算机网络定义与分类

(2)计算机网络体系结构

2、物理层

(1)物理层的基本概念

(2)数据通信的基础知识

(3)传输介质及其特性

(4)信道复用技术

(5)数字传输系统

(6)宽带接入技术

3、数据链路层

(1)数据链路层功能和设计要点

(2)错误检测和纠正

(3)基本数据链路协议，包括：停止-等待协议、后退N帧协议和选择重传协议；

(4)滑动窗口协议

(5)点对点协议PPP

(6)介质访问控制协议，包括介质访问控制基本概念、协议分类、CSMA/CD协议；

(7)以太网，包括MAC地址、IEEE局域网标准、以太网、高速以太网技术；

(8)局域网互连技术，包括物理层及数据链路层互连技术、网桥概念和工作原理、局域网交换机工作原理；

(9)无线局域网(IEEE802.11)基本知识，包括CSMA/CA协议原理等。

4、网络层

(1)网络层提供的数据报和虚电路服务

(2)IP协议及ARP协议

(3)划分子网和构造超网

(4)ICMP协议

(5)路由算法及协议，包括路由表及路由转发、路由算法分类、距离向量路由算法及RIP协议、链路状态路由算法及OSPF协议、BGP基本原理；

(6)IP组播基本原理、特点及用途

(7)网络地址转换NAT原理

(8)IPv6基本知识，包括：IPv6特点、地址、包结构等

5、传输层

(1)传输层功能及提供的服务

(2)UDP协议

(3)TCP协议，包括：报文段格式、可靠传输、流量控制、拥塞控制和连接管理。

6、应用层

(1)套接字编程接口及端口概念

(2)域名系统DNS

(3)文件传送协议

(4)万维网WWW原理及HTTP协议

(5)电子邮件系统构成与协议

## <a name="2">复习提纲</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

## <a name="3">计算机组成原理</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

### <a name="4">（一）计算机系统概述</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### （1）计算机系统的基本组成与层次结构

**计算机系统的基本组成：**

硬件系统：看得见的物理实体，电子线路和电子元件等

软件系统：解决问题的思想、方法，包括程序和数据

固件：固化的软件，firmware，本质是软件

**计算机硬件的基本组成：**

冯·诺依曼结构：
- 输入设备：将信息输入到计算机的外部设备，如键盘、鼠标等
- 输出设备：输出计算机处理结果的外部设备，如显示器、打印机等
- 存储器：存放程序和数据，按地址访问
- 运算器：执行算术运算和逻辑运算，必备寄存器：累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、程序状态寄存器/标志寄存器（PSW）
- 控制器：由程序计数器（PC）、指令寄存器（IR）、控制单元（CU）组成，根据指令的操作码、指令执行过程中的条件状态、时序系统等三方面的因素来产生指令执行过程中所需要的控制信号，控制指令的执行

*重要概念——存储字长：存储单元中的二进制代码位数，等于数据线的数量，等于MDR的位数（顺便：MAR的位数是log2存储单元个数，与PC长度相等），一般小于等于机器字长，是1字节的偶数倍。*

*重要概念——CPU：图示见王道p4。CPU包含{ALU、通用寄存器组GPRs、标志寄存器}、{CU、IR、PC}、MAR、MDR。*

冯·诺依曼计算机特点：（真题2019）

组成：运算器、控制器、存储器、输入和输出设备

存储程序：
- 指令和数据以**二进制**形式存放在存储器中
- 指令顺序存放，存储器按地址访问

程序控制：
- 程序运行时，控制器逐条从主存中取出指令，控制全机相关部件执行相应操作，完成指令的功能直至完成程序的功能
- 由指令控制计算机的运行
- 由控制器来控制数据的存取及程序的执行
- 程序顺序执行，遇到分支指令可能改变顺序

**计算机软件系统分类:**

应用软件:解决应用问题的程序集合，如各种科学计算类程序、工程设计类程序、数据统计与处理程序、情报检索程序等

系统软件：管理和调度计算机，方便用户使用计算机并提高使用效率的程序的集合
- 操作系统（OS）、数据库管理系统（DBMS)
- 分布式软件系统、网络软件系统、标准库程序
- 语言处理程序：
    - 编译器：将高级语言转换成汇编语言
    - 汇编器：将汇编语言转换成机器指令
    - 解释器：将高级语言直接翻译成机器指令，如JAVA

软硬件功能逻辑等效：
- 同一功能即可软件实现，也可以硬件实现
- 软件灵活性高，性能差，成本低
- 硬件效率高，成本高
- 功能划分要折中考虑

**计算机系统的层次结构：**

软件层（虚拟计算机）：
- 高级语言层 
- 汇编语言层    
- 操作系统层（由操作系统程序实现，由机器指令和广义指令组成，因此也被称为混合层）

硬件层：
- 指令集架构层（传统机器语言层）（组原讨论对象）
- 微代码层（可选）（微程序解释机器指令）（组原讨论对象）
- 逻辑门层（实体硬件）

![](https://api2.mubu.com/v3/document_image/e582b4cf-04cd-44ed-a905-f5cac0e939be-329792.jpg)

**计算机系统的工作过程：（真题2015、2016）**

- 1.“存储程序”工作方式
- 2.从源程序到可执行文件：hello.c->(预处理器cpp)->hello.i->(编译器ccl)->hello.s->(汇编器as)->hello.o+prinf.o->(链接器ld)->hello
- 3.程序的执行过程：数据在CPU、主存储器和I/O设备之间流动，通过总线、I/O接口进行
- 4.指令的执行过程：略

**王道习题：**

一轮标记题：2 7 9 14 19 20 22 23

二轮重做：2 5 9 14 19 23 24

大题：

01.
- 解：略
- 答：存储程序是指将指令以代码的形式事先输入计算机主存，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。计算机按照此原理应该具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能


错题总结：
- 冯·诺依曼机的基本工作方式是控制流驱动方式
- 编译程序（编译器）既能输出汇编语言，也能输出机器语言，**现代编译器主要采用生成汇编代码（assembly code）的策略，而不直接生成二进制的目标代码（binary object code）**
- 硬件描述语言（英文：Hardware Description Language，简称：HDL）是电子系统硬件行为描述、结构描述、数据流描述的语言。利用这种语言，数字电路系统的设计可以从顶层到底层（从抽象到具体）逐层描述自己的设计思想，用一系列分层次的模块来表示极其复杂的数字系统。然后，利用电子设计自动化（EDA）工具，逐层进行仿真验证，再把其中需要变为实际电路的模块组合，经过自动综合工具转换到门级电路网表。接下去，再用专用集成电路 ASIC 或现场可编程门阵列 FPGA 自动布局布线工具，把网表转换为要实现的具体电路布线结构。**这是一个很容易望文生义的专业词汇**

#### （2）计算机系统的性能指标：吞吐量、响应时间、带宽、延迟；CPU时钟周期、主频、CPI、CPU执行时间；MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS

**静态性能指标：**
- 机器字长：CPU一次处理的数据位数；与寄存器、运算器、数据总线的位宽相等；决定数据表示范围和精度
- 带宽：数据总线一次所能并行传送信息的位数，这里指外部总线的宽度。
- 主存容量：主存储器所能存储信息的最大容量。

**时间相关性能指标：（背30）**
- 吞吐量：指系统单位时间内处理请求的数量，主要取决于主存的存取周期。
- 响应时间：用户向计算机发送一个请求，到系统对该请求做出相应并获得结果所用的时间。响应时间越短，吞吐率越大。程序执行时间 = CPU时间 + 等待时间（磁盘、存储器访问、I/O操作、OS开销）
- 延迟：内存延迟是从开始请求内存中的字节或字，到处理器检索到它之间的时间。如果数据不在处理器的缓存中，则获取它们需要更长的时间，因为处理器必须与外部存储单元通信。因此，延迟是衡量内存速度的基本指标：延迟越少，读取操作就越快。延迟不应与衡量内存吞吐量的内存带宽混淆。延迟可以用时钟周期或以纳秒为单位测量的时间来表示
- CPU时钟周期：时钟频率的倒数，是处理操作最基本的时间单位
- 主频：时钟周期的倒数，同等条件下，频率越高，性能越好。但频率不可能无限提升，存在散热问题，串扰问题等，单位赫兹Hz
- CPI：执行每条指令所需的平均时钟周期数，Clock cycle Per Instruction
- CPU执行时间：程序执行期间真正消耗CPU的时间，**取决于①主频、②CPI、③指令条数（指令集）三要素**
- MIPS：每秒执行多少百万条指令数量，Million Instructions Per Second
- MFLOPS:
    - **每秒执行多少百万次浮点操作，Mega Floating-Point Operations Per Second，用于衡量科学计算性能**
    - 更小单位：kFLOPS，k小写
    - 更大单位：**GFLOPS、TFLOPS、PFLOPS**、EFLOPS、ZFLOPS，**Giga、Tera、Peta**、Exa、Zetta，每个单位相差1000倍
    - 还有一些常用的英文前缀：kilo(3)、hecto、deca、deci、centi、milli(-3)、micro(-6)、nano(-6)、pico(-9)
- 基准程序：专门用来进行性能评价的一组程序，但也存在缺陷（比如硬件设计人员根据benchmark代码进行特别优化）

**王道习题：**

一轮标记题：10 13 14

二轮重做：13 22 

大题：1 3

1.
- 解：MDR：32位，MAR：16位，IR：32位，PC：16位，X = ACC = MQ = 32位；信息通路：嗯……
- 答：信息通路：PC->MAR, Ad(IR)->MAR, MDR->IR, MDR->ACC（取数）, ACC->MDR（存数）, MDR->X

2.
- 解：CPI = 0.6 * 1 + 0.18 * 2 + 0.12 * 4 + 0.1 * 8 = 2.24; CPU时间 = I * CPI / f = 5.6 * 10 ^ -8; MIPS = f / (CPI * 10 ^ 6) = 17.86
- 答：解答正确，注意CPU执行时间的单位是秒

3.
- 解：
    - 1) T = 1 / f = 1.25 * 10 ^ -7秒
    - 2) T = 1 / 0.4MIPS =  2.5 * 10 ^ -6秒
    - 3) 0.4MIPS = f / CPI * 10 ^ -6, 解得CPI = 20; 平均指令执行速度 = 1 / (CPI * T) = 12 * 10 ^ 6 / 20 = 6 * 10 ^ 5
- 答：解答正确。所谓“平均指令执行速度”，其实就是在说MIPS，最后的写法也建议写成MIPS的形式

4.
- 解：老CPI：1.57；新指令总数：0.79M + 0.21M * 0.75 = 0.9475M, CPI = ...
- 答：新指令总数算错了。算术逻辑和Load指令都是减去0.43 * 0.25M，新增的新算术逻辑指令也是0.43 * 0.25M

错题总结：
- 兼容指计算机软件**或**硬件的通用性
- 单片机（Single-Chip Microcomputer）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/O口和中断系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机系统，在工业控制领域广泛应用

#### 本章小结

- 机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直接执行
- 翻译程序分为编译程序和解释程序，汇编程序则是特指从汇编语言翻译到机器语言的程序
- *字长 = 机器字长，指令字长 = 一个指令字中包含的二进制代码的位数，存储字长：一个存储单元存储的二进制代码的位数，若指令字长是存储字长的2倍，则需要两个访存周期来取出一条指令*
- 两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器**如何实现其指令**，完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个**结构**的问题，但实现乘法指令采用什么方式则是一个**组成**的问题。许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大

### <a name="5">（二）数据的表示和运算</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### （1）数制与编码

进位制数及其相互转换:
- 二进制编码：两种状态，容易与物理状态对应；位数有限时不能表示循环小数；运算规则简单，适合用布尔代数设计电路，制造成本低
- 数制转换
    - 二进制转十进制：加权展开
    - 十进制到二进制：整数除2取余，先余为低；小数乘2取整，先整为高
    - 二进制转8进制或16进制：从小数点向左右3/4位一分组

BCD码：
- 8421码：1010到1111是无效码，要加6修正
- 余3码：8421码的基础上每种编码加3
- 2421码：也是一种有权码，权值由高到低分别为2,4,2,1，特点是大于等于5的4位二进制数中最高位为1，小于5的最高位为0

机器码：**在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。补码是重点，会结合代码，指令格式（立即数，相对寻址）进行考察！**
- 原码：存在正零和负零两个零
- 反码：当真值为正数时，反码和原码相同；当真值为负数时，数值部分要逐位取反。也存在正零和负零两个零。主要用于求补
- 补码：*数据表示建立在“模”的概念基础上，模的值即为符号位进位的权值*
    - 模2的补码：定点小数模值为2，定点整数模值为2 ^ ( n + 1 )
    - 模4的补码：变形补码，定点小数模值为4，定点整数模值为2 ^ ( n + 2 )，其中**n为数值位位数**
    - 当真值为负数时，补码等于真值加上模
    - 在数轴上的表示区间不对称：机器零唯一，最左侧比原码、反码多表示一个最小负数
    - 补码符号位可以直接参与加减运算，运算电路实现方便，因此计算机中整数采用补码进行存储、表示和运算
    - 补码和真值之间的转换：正数与原码一致，**负数都遵循“数值位逐位取反、末尾加一”的规则**
- 移码：
    - 只用于表示整数，也称偏移码，真值 + 常量
    - 方便比较大小，数字越大，真值越大
    - **移码和补码的符号位相反，数值位相同**
    - 用于表示浮点数的阶码
- 机器码表示范围（只需记住补码公式，加模数）：
![](https://api2.mubu.com/v3/document_image/8274186f-11f0-4065-8723-aafe9a0220e4-329792.jpg)
- 机器码在数轴上的表示（对比理解）：
![](https://api2.mubu.com/v3/document_image/d971313c-94f7-483b-ad4f-a9f500063e43-329792.jpg)

**王道习题：**

一轮标记题：1 3 4 7 13 14 17 25 26 28 29 30

二轮重做：17

错题总结：
- 使用补码表示时，若符号位相同，则数值位越大码值越大

#### （2）定点数和浮点数的表示和运算

定点数的表示：
- 定点数概念：小数点位置固定的数
- 定点数分类
    - 有符号数、无符号数：机器码到底有无符号取决于输出形式。C语言中printf中%d输出，%u表示无符号
    - 定点整数和定点小数：
        - 定点小数：小数点隐含在符号位之后，有效数值部分最高位之前
        - 定点整数：小数点在有效数值部分最低位之后
    - 溢出问题：
        - 定点整数存在上溢问题（超出表示范围）
        - 定点小数存在精度溢出问题（超出表示精度）

**定点数的移位运算：**
- 算术移位：**符号位保持不变**
符号|码制|添补代码
:-:|:-:|:-:
正数|原码、补码、反码|0
负数|原码|0
负数|补码左移|0
负数|补码右移|1
负数|反码|1
- 逻辑移位：将操作数视为无符号数，不管左移还是右移，都补0
- 循环移位：
    - 带进位标志位CF（大循环）：CF参与循环
    - 不带CF（小循环）：CF存储最新移出的数字的副本

原码定点数的加减运算（没考过）：
- 符号位不能直接参与运算
- 加法运算需要“同号求和，异号求差”
- 减法运算需要“异号求和，同号求差”
- 求差时还需要先比较大小，然后用大数减去小数
- 结果的符号选择也相对复杂，运算复杂

**补码定点数的加减运算：**
- 运算公式：设机器字长为n + 1：
    - [A + B]补 = [A]补 + [B]补 (mod 2 ^ (n + 1))
    - [A - B]补 = [A]补 + [-B]补 (mod 2 ^ (n + 1))
- 运算规则：
    - 操作数采用补码表示，符号位参加运算
    - 运算的结果为补码，符号位的进位位（模）直接丢弃

定点数的乘法运算（几乎没考）：
- 原码乘法运算：
    - 运算过程见改错本p1
    - 符号位单独运算
    - 被乘数取双符号位，右移n次，加n次
- 补码乘法运算（Booth算法）：
    - 运算过程见改错本p1
    - 符号位参与运算
    - 被乘数取双符号位，乘数取单符号位，末尾增加一附加位，右移n次，加n + 1次
- 原码除法运算（恢复余数法）：
    - 循环次数不固定，不利于机器控制
- 原码除法运算（不恢复余数法）：
    - 运算过程见改错本p2
    - 符号位单独运算
    - 被除数（余数）和商均为单符号位，左移n次，加n + 1次
    - 第n + 1步的余数为负时，需要加上|Y|得到正确的余数
- 补码除法运算（加减交替法）：
    - 运算过程见改错本p3
    - 符号位参与运算
    - 被乘数取双符号位，乘数取单符号位，左移n次，加n + 1次
    - 若对商的精度没有特殊要求，则一般采用“末位恒置1”法

**溢出的概念和判别法：***仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出（可用来快速判断）*
- 采用一位符号位：由于减法运算是用加法器实现的，因此只需遵循加法的溢出规则“正正得负，负负得正”即可：
![](https://api2.mubu.com/v3/document_image/eb154771-892b-493a-af75-e7b4c4a8cfaa-329792.jpg)
- 采用双符号位：00正数，01正溢出，10负溢出，11负数。主要用于手工计算，方便肉眼识别，计算机因为成本问题不采用
- 采用一位符号位根据数据位的进位情况判断溢出：若符号位的进位Cn和最高数位的进位Cn-1相同，则说明没有溢出，否则表示发生溢出，即：OF = Cn ⊕ Cn-1

**王道习题：**

一轮标记题：4 10 11 14 15 19 22 25 26 27 31 33 35 38 43

二轮重做：14 26 27 38 41 43(溢出、进位/借位的快速判断?)

大题：1 2 8
1.（加入改错本）
- 解：全部算错！32位数是-2147483648 ~ 2147483647！
- 答：
    - 1) 2 ^ 31 + 2 ^ 2; 2 ^ 30 + 2; 4000 0002H; **2 ^ 32 + 2 ^ 3, 发生溢出**; 0000 0008H
    - 2) -(2 ^ 31 - 2 ^ 2); -(2 ^ 30 - 2); C000 0004H; **(2 ^ 32 - 2 ^ 3), 发生溢出**; 0000 0008H

2.
- 解：
    - 1) 86H; 90H; 7CH;
    - 2) -122; -112
    - 4) 最后一条语句执行时会发生溢出，理由略
- 答：
    - 3) 能。n位加法器实现的是模2^n无符号整数加法运算。对于无符号整数a和b，a + b可以直接用加法器实现，而a-b可用a加b的补数实现，所以n位无符号整数加减运算都可在n位加法器中实现；由于有符号整数用补码表示，补码加减运算公式为[a + b]补 = [a]补 + [b]补 (mod 2 ^ n)，[a - b]补 = [a]补 + [-b]补 (mod 2 ^ n)，所以n位有符号整数加减运算都可在n位加法器中实现

3.
- 解：0.1001; 0.1101

4.（加入改错本）
- 证明：采用定点小数表示，条件为|X<1|，|Y<1|，|X+Y<1|，所以要分4种情况证明
- 解析：**本题考查定点小数补码的定义，需牢记！**

5.
- 解：0010

6.
- 解：0.1110

7.
- 解：
    - 1) BCH, B0H;
    - 2) 6CH, OF = 1, SF = 0
    - 3) 0CH, OF = 0, SF = 0

8.（不加入改错本，但要复习！）
- 解：
    - 1) 乘法指令可以通过Booth算法利用加减和位移等指令实现
    - 4) 带符号和无符号均为: FF FF FF FEH; umul()没有溢出，mul()溢出
- 答：
    - 1) 乘法运算可以通过加法和移位来实现。编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法和移位等指令实现乘法运算
    - 2) 控制逻辑的作用是控制循环次数，控制加法和移位操作
    - 3) **a)最长，c)最短。对于a)，需要用循环代码段（即软件）实现乘法操作，因而需要反复执行很多条指令，而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长；对于b)和c)，都只需用一条乘法指令实现乘法操作，不过b)中的乘法指令需要多个时钟周期才能完成，而c)中的乘法指令可在一个时钟周期内完成，所以c)的执行时间最短**
    - 4) 应该是00 00 00 00 FF FF FF FEH。umul()没有溢出，mul()溢出。对于无符号整数乘法运算，高n位全为0就足以说明运算结果没有溢出，否则溢出，理由略

错题总结：
- 三种溢出判别方法，均须有溢出判别电路，可用“异或”门来实现
- 存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的。只在把两个模4补码的数送往ALU完成加减运算时，才把每个数的符号位的值冏时送到ALU的双符号位中，即只在ALU中采用双符号位
- 来自26题的B选项，非常复杂，三轮可以直接跳过，只记结论：**对于补码的不恢复余数除法，同号相除时，**那就和符号位不参与运算的原码不恢复余数法没有区别，也就是说，**够减（余数为正）商1，不够减（余数为负）商0；异号相除时，**则相反，**够减商0，不够减商1。**好奇推理过程，可参考：https://blog.csdn.net/H_define/article/details/125877290
- 补码表示时，正数的符号位为0，左移最高位为0时，数据不会丢失；负数的符号位为1，左移最高位为1时，数据也不会丢失。也就是说，左移移走的最高位要与符号位相同（才不会溢出）
- 大题第1题：网友-Jjonak：王道写的真误导人啊，讲课也没讲明白，直接就是一句符号位不动，数值位移动，做题目发现不对劲，查了查发现是**符号位也移动，只是没溢出的情况下符号位就好像没移动的意思**

**浮点数的表示：**
- 表示方法：N = ((-1) ^ S) × (R ^ E) × M
    - 数符 S：取值0或1，用来决定浮点数的符号
    - 阶码/指数 E：一个二进制定点整数，用移码表示
    - 尾数 M：一个二进制定点小数，一般用定点原码小数表示
        数符：浮点数的符号
        尾数：尾数数字部分
    - 基数（隐含） R：可以约定为2、4、16等
    - 阶码的值反映浮点数的小数点的实际位置，阶码的位数反映浮点数的表示范围，尾数的位数反映浮点数的精度
    - **浮点数的表示法也不止上面这一种，比如阶码也可以用原码表示，但比较统一的一点是，阶码往往在尾数的前面**
- 溢出问题：
    - 存在正上溢和负上溢（统称为上溢）问题（此时计算机必须进行中断处理）
    - 存在正下溢和负下溢（统称为下溢）问题（此时浮点数值趋于零，计算机仅将其当作机器零处理）
    - 也存在精度溢出问题（无法精确表示，只能舍入处理）
- 尾数规格化：调整尾数和阶码，保证尾数最高位是有效值1，这样可以提高运算精度，充分利用尾数有效位
    - 左规：尾数左边无效位太多，往左移，左规可多位。阶码减少，尾数增大
    - 右规：尾数运算溢出时要进行右规，右规最多一位。阶码增加，尾数减小
    - 原码规格化数（绝对值大于等于0.5）
        - 正数：0.1xxx
        - 负数：1.1xxx
        - 尾数最高位为1
    - 补码规格化数
        - 正数：0.1xxx
        - 负数：1.0xxx（注意：补码的-0.5不是规格化数，且补码下限可以为-1）
        - 符号位和尾数最高位相反
        - **大多数题目在规格化时都是IEEE754浮点数，但某些题目可能会指定尾数或阶码采用补码表示。通常采用双符号位，当尾数求和结果溢出（如尾数为10.××···×或01.××···×）时，需右规一次；当结果出现00.0××···×或11.1××···×时，需要左规，直到尾数变成00.1××···×或11.0××···×**
    - *基数不同，浮点数的规格化形式也不同。浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1。基数为4时，原码规格化形式的尾数最高两位不全为0*
- 浮点数在数轴上的分布：
    - 刻度并不均匀，越往右，浮点数越稀疏
![](https://api2.mubu.com/v3/document_image/95e59a35-5996-4253-b34e-dba717048f00-329792.jpg)
- 浮点运算不满足结合律：
    - 小数a + 大数b = 大数b（有可能）
    - 编程时浮点数比较要小心

**IEEE754标准：**
- 二进制浮点数
    - 数符S、阶码E和尾数M
    - 阶码采用移码表示
    - 尾数采用原码数据表示：隐藏高位1，运算时还原成1.M形式
    - 二进制浮点数无法精确表示一些十进制小数（0.1 0.2 0.4等转换成二进制都是循环小数）
    - 对32位单精度格式而言：S为1位，E为8位，采用偏移值为127的移码，M为23位
![](https://api2.mubu.com/v3/document_image/91eaba8b-3da0-4775-8fb7-ef9e3d1b9949-329792.jpg)
- 十进制浮点数
    - 可精确表示十进制浮点数，保证运算精度
    - 解决二进制浮点运算引起的误差问题
    - IEEE-754 2008标准中有定义
- IEEE754表示范围
    - **阶码为全1时，表示无穷大或非数，即：浮点数除零不会异常**
    - **阶码和尾码全零时表示机器零**
    - *阶码为零，尾数不为零时表示非规格化数*
    - *其他表示区间为规格化数*
    - 各类区间及浮点数的最大值、最小值问题：注意，0.111···1 = 1 - 2 ^ 23（常考）；注意，单精度非规格化是-126
![](https://api2.mubu.com/v3/document_image/d5bcad7b-9e5e-4969-921e-a55562f4106f-329792.jpg)
![](https://api2.mubu.com/v3/document_image/b0ed425c-8d6f-4e13-bbad-3b76df3ed2db-329792.jpg)

**浮点数加减运算（难）：**
- 对阶
    - 小阶向大阶看齐
    - 阶码增加，尾数右移
- 尾数运算
- 规格化
    - 尾数运算上溢：右归最多一位
    - 尾数规格化下溢：左归处理，可以多位
- 舍入处理
    - 0舍1入：舍去位最高位为1，尾数最低位加1，否则舍去。这样可能会使尾数溢出，此时需要再做一次右规
    - 恒置1法：舍去中有一位是1，尾数最低位置1
    - 截断法：直接截取所需位数，丢弃后面的所有位
- 溢出判断
    - 浮点数的溢出并不是以尾数溢出来判断的，尾数溢出可以通过右规操作得到纠正。运算结果是否溢出主要看结果的指数是否发生了上溢，因此是由阶码上溢来判断
    - 上溢：进入异常处理
    - 下溢：按机器零处理
- 注意IEEE754浮点数与采用补码表示阶码和尾数的浮点运算法则的相同和不同之处，考研有真题考到过！

**程序中的数据表示与运算（常考）：**
- 汇编语言中的数据类型
    - 寄存器、存储器操作数本没有数据类型
    - 对该数进行何种数据类型的操作完全取决于指令功能
    - 有符号运算、无符号运算、定点运算、浮点运算指令
- C语言中数据类型
    - 整型
        - 有符号整型包括char、short、int、long
        - 分别采用8、16、32、64位补码进行表示
        - 通过unsigned声明为无符号类型
    - 整型运算溢出问题
        - 有符号整数和无符号整数、浮点数都存在运算溢出的问题
        - C语言不做溢出判断，需要程序员特别注意
    - 浮点型
        - C语言中常见的浮点数为float、double
        - 分别对应IEEE 754中的单精度和双精度浮点数
        - 不同数据类型的运算会在编译器的翻译下变成不同类型的汇编指令
    - 强制类型转换（难）
        - 相同位宽的整型数据进行强制转换时机器码保持不变
        - 小字长转大字长时，无符号整型进行零扩展，有符号整型进行符号扩展
        - 大字长转小字长时直接将机器码截短
        - float → double：由于double型数据的尾数、阶码宽度都比float型大，因此其表示范围更大、精度更高，转换后的 double 型数据与原 float 型数据完全相等
        - double → float：大数转换时可能发生溢出，高精度数转换时会发生舍入
        - float/double → int：小数部分会截断，大数转换时可能会溢出
        - int → float：两种类型都是 32 位，所表示的状态数是一样的，在数轴上表示的数据并不完全重叠，float 型用其中一部分状态表示了更大的整数和小数；- int 型中一些比较大的整数无法用float型精确表示。浮点数尾数连隐藏位在内一共24位，当int型数据的24～31位数据非0时，无法精确转换成 24 位浮点数的尾数，此时会发生精度溢出，需要进行舍入处理
        - int → double：浮点数尾数字段为 53 位，可以精确表示所有 32 位整数
        - 一些很有用的例子，回去慢慢看：
![](https://api2.mubu.com/v3/document_image/27750e8a-60b9-4faa-a47c-60a6d749286e-329792.jpg)

**王道习题：**

一轮标记题：5 7 10 12 13 14 17 20 21 22 23 24 25 27 28 29 30

二轮重做：5 7 17 21

大题：4 5 7 8
1.
- 答：
    - 阶码上溢出。一个正指数超过了最大允许值时，浮点数发生上溢出（即向 ∞ 方向溢出)。若结果是正数，则发生正上溢出（有的机器把值置为 +∞ ）；若结果是负数，则发生负上溢出（有的机器把值置为 -∞ ）。这种情况为软件故障，通常要引入溢出故障处理程序来处理
    - 阶码下溢出。一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为 0（+0或-0）。不发生溢出故障
    - 尾数溢出。当尾数最高有效位有进位时，发生尾数溢出。此时，进行“右规”操作：尾数右移一位，阶码加 1，直到尾数不溢出为止。此时，只要阶码不发生上溢出，浮点数就不会溢出
    - 非规格化尾数。当数值部分高位不是一个有效值时（如原码时为 0 或补码时与符号位相同），尾数为非规格化形式。此时，进行“左规”操作：尾数左移一位，阶码减1，直到尾数为规格化形式为止

2.
- 解：略

3.
- 解：1)ture; 2)不一定true; 3)true; 4)不一定true

4.
- 解：1)好困，三刷的时候再算吧

5.
- 解：1)同上

6.
- 答：两个n位数的加减运算，其和/差最多为n+1位，因此有可能需要右规，但右规最多一次。由于异号数相加或同号数相减，其和/差的最少位数无法确定，因此左规的次数也无法确定，但最多不会超过尾数的字长n位次

7.
- 解：
    - 1)机器零，+0
    - 2)48
    - 3)非规格化数，-2 ^ -127
    - 4)负无穷大

8.
- 解：
    - 1) 会，原因略；不会，原因略；
    - 2) 相等；f1(23)返回值的机器数为00 FF FF FFH, f2(23)返回值的机器数为4B 7F FF FFH
    - 3) 浮点数的精度不够
    - 4) 超出int范围，溢出了；30
    - 5) 正无穷；126；23


错题总结：
- **对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况**
- 与非规格化浮点数相比，采用规格化浮点数的目的主要是为了增加数据的表示精度
- 舍入是浮点数的概念，定点数没有舍入的概念。浮点数舍入的情况有两种：对阶、右规格化（注意，**右规可能引起阶码上溢，但对阶没这个可能**）。舍入不一定产生误差，如向下舍入11.00到11.0时是没有误差的
- 各类区间及浮点数的最大值、最小值问题：注意，0.111···1 = 1 - 2 ^ 23（常考）；注意，单精度非规格化，阶码是-126，没有隐含的高位1

#### （3）算术逻辑单元ALU

一位全加器：全加器（FA）是最基本的加法单元，逻辑表达式和逻辑电路如下：
![](https://api2.mubu.com/v3/document_image/d4b7af6f-4584-4804-b25b-82dbe4691705-329792.jpg)
![](https://api2.mubu.com/v3/document_image/e7354005-28dc-4b31-aad7-09d1c2c20423-329792.jpg)

**1）串行加法器和并行加法器**

串行加法器：
串行进位加法器：把n个加法器相连。串行进位又称行波进位，因为每级进位直接依赖于前一级的进位，即信号是逐级形成的。因此，**该加法器的运算速度和位数是线性关系**，位数越多，延迟时间就越长，而全加器本身的求和延迟只是次要因素。逻辑电路如下，注意其中的异或电路需要3T：
![](https://api2.mubu.com/v3/document_image/3eacad7e-b067-4be0-bb28-e2cbb58616f2-329792.jpg)
可控加减法电路：减法变加法，输入增加异或门，控制位送进位输入，逐位取反，末位加1。有符号无符号运算均适用，区别是溢出检测逻辑。逻辑电路如下：
![](https://api2.mubu.com/v3/document_image/4ab15384-9327-424e-ac65-4785220b98f7-329792.jpg)

并行加法器：
- 主要原理：采用先行进位电路提前得到所有进位位。因此，各位的求和运算可以并发运算。注意：先行进位电路也有开销和时间延迟
- 进位生成函数：
![](https://api2.mubu.com/v3/document_image/c28f2020-0709-4abd-8f1b-2032abfb35f8-329792.jpg)
- 进位传递函数：
![](https://api2.mubu.com/v3/document_image/7716ed85-94d2-4f8c-b49a-92ca21c371bc-329792.jpg)
- 进位信号仅仅与G，P，C0有关：
![](https://api2.mubu.com/v3/document_image/7dc167b8-b1ca-43a8-bc56-53a8c603f331-329792.jpg)
- 先行进位电路：
![](https://api2.mubu.com/v3/document_image/a96cee4e-04af-4fd9-8da2-4d699e861e40-329792.jpg)
- 四位快速加法器：
![](https://api2.mubu.com/v3/document_image/4d2ac825-0803-40cf-9ac5-45657dd1977c-329792.jpg)
- 先行进位电路级联：
![](https://api2.mubu.com/v3/document_image/4d959d83-ab59-4a96-9c0e-b602a6faa840-329792.jpg)
- 两级或多级先行进位方式：组内**并行**，组间**并行**

带标志加法器：增加生成相应的标志信息的逻辑电路：
- 溢出标志的逻辑表达式为OF = Cn ⊕ Cn-1，OF= 1表示带符号整数运算时发生溢出。对于无符号数运算，OF没有意义
- 符号标志就是和的符号，即SF = Fn-1，表示结果的符号，即F的最高位。对于无符号数运算，SF没有意义
- 零标志ZF = 1当且仅当F = 0，不管对于无符号数还是带符号整数运算，ZF都有意义
- 进位 / 借位标志CF =Cout ⊕ Cin（或者是记作Sub），即当Cin = 0（加法）时，CF为进位Cout，当Cin = 1（减法）时，CF为进位Cout取反。对于带符号数运算，CF没有意义

**2）算术逻辑单元ALU的功能和结构**

- 定点运算器
    - 算术逻辑运算单元ALU：算术逻辑运算单元是运算器的核心，由它实现算术逻辑运算
    - 通用寄存器组：通用寄存器组的作用是暂存参加运算的数据、运算的中间结果或最后结果
    - 输入选择电路：输入选择电路的作用是对若干个数据的输入进行选择或控制
    - 输出控制电路：输出控制电路对加法器的输出进行控制
- 运算器结构
    单总线结构：2个缓冲器，3个时钟完成运算
    双总线结构：1个缓冲器，2个时钟完成运算
    三总线结构：0个缓冲器，1个时钟完成运算
- 运算流水线
    - 浮点流水线，将浮点运算的步骤进行细分
    - 不提升单个运算的性能，优化密集型浮点运算性能
![](https://api2.mubu.com/v3/document_image/dba9a987-352f-4265-b9fa-abe403fc12f8-329792.jpg)

#### 其他

**字符与字符串：**

- ASCII码：国际通用的字符码，7位表示 128 个字符。实际占用 1 个字节，最高有效位 MSB = 0。有 33 个控制字符，其余为可打印字符：
    - 20H 开始是空格等可打印字符
    - 0 ～ 9 这 10 个数字是从 30H 开始的一个连续区域
    - 大写英文字母是从 41H 开始的一个连续区域
    - 小写英文字母是从 61H 开始的一个连续区域
- 汉字编码：
    - 输入码：汉字的输入。拼音，五笔等
    - 机内码：汉字的存储。GB2312、GBK、GB18030、Unicode、BIG5等标准
    - 字形码：汉字的输出
    - GB2312：
        - 区位码：矩阵形式，由4位十进制数构成，前2位区码，后2位位码
        - 汉字机内码：区位码（16进制）+ A0A0H（为区分ASCII码，MSB = 1），即：GB2312汉字占用两个字节，有效位14位
- 字符串：以"\0"结束的字符序列

#### 本章小结

- 用移码表示浮点数的阶码有什么好处？
    - 浮点数进行加减运算时要比较阶码的大小，移码比较大小更方便
    - 检验移码的特殊值（0和max）时比较容易。阶码以移码编码时的特殊值如下。0：表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近0，在尾数也为0时可用米表示0；尾数不为零表示未正规化的数。max：表示指数正无穷大，若尾数为0，则表示浮点数超出表示范围（正负无穷大）；尾数不为0，则表示浮点数运算错误
- 计算机内部的数值数据并非都是二进制数。在计算机内部，数值数据的表示方法有以下两大类：
    - 直接用二进制数表示。分为有符号数和无符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息)
    - 二进制编码的十进制数，一般采用BCD码表示，用来表示整数
- 什么称为无符号整数的“溢出”？实际上，对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低n位，舍弃高位。这样，会产生以下两种结果：
    - 保留的低n位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第n+1位，称此时发生了“溢出”现象
    - 保留的低n位数能正确表达计算结果，即高位的舍去并不影响其运算结果
- 现代计算机中是否需要考虑原码加减运算？如果要，如何实现？
    - 因为现代计算机中浮点数采用IEEE 754标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为IEEE 754规定浮点数的尾数都用原码表示。原码的加减运算可以有以下两种实现方式：
        - 1）转换为补码后，用补码加减法实现，结果再转换为原码
        - 2）直接用原码进行加减运算，符号和数值部分分开进行

## <a name="10">操作系统</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

### <a name="11">（一）操作系统概述</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### a)操作系统的基本概念；内核态与用户态、中断、异常和系统调用。

**操作系统的基本概念：**

操作系统：控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合

操作系统的特征：
- 并发（Concurrence）
- 共享（Sharing）：分为互斥共享方式和同时访问方式
- 虚拟（Virtual）：时分复用，如处理器的分时共享；空分复用，如虚拟存储器
- 异步（Asynchronism）：进程以不可预知的速度向前推进

操作系统的目标和功能：
- 四个「管理」
- 作为用户与计算机硬件系统之间的接口：分为命令接口和程序接口，前者又分为联机命令接口和脱机命令接口
- 实现对计算机资源的扩充

**王道习题：**

二轮重做：10 17

大题：
1.
- 解：略
- 答：**库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高，因为使用系统调用时，需要上下文的切换及状态的切换（也就是由用户态转向核心态）**

**操作系统的运行环境：**

处理器运行模式：
- 核心态 / 管态 / 内核态：操作系统的管理程序执行时处理机所处的状态。在此状态下处理机可使用全部指令（包括特权指令）；可以使用全部系统资源（包括整个存储区域）。以下内容的指令操作都工作在核心态：
    - 时钟管理：提供系统时间；通过时钟中断来实现进程的切换
    - 中断机制：只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序
    - 原语：操作系统最底层；具有原子性；运行时间短且调用频率高
    - 系统控制的数据结构及处理：进程管理、存储器管理、设备管理
    - 注意：**切换到用户态的指令也是特权指令**
- 用户态 / 目态：用户程序执行时处理机所处的状态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域
    - 转到核心态的时机：用户程序访问系统资源（访管中断）、中断（I/O、时钟、通信等）、异常（故障、终止）
    - 注意：访管指令显然不可能是特权指令
    - 注意：**由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的**

中断、异常、系统调用：
- 中断（Interruption）：也称**外中断**，指某个事件 (例如电源掉电、I/O传输结束等) 发生时，系统中止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点继续执行的过程。**外中断可分为可屏蔽中断和不可屏蔽中断**。可屏蔽中断是指通过 INTR 线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。不可屏蔽中断是指通过 NMI 线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的
- 异常（Exception）：也称**内中断**，是由处理机内部事件引起的中断，**可分为故障（Fault）、自陷（Trap）、终止（Abort）**。异常可分为故障、自陷和终止。故障（Fault）通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。自陷（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。**故障异常和自陷异常属于软件中断（程序性异常)，终止异常和外部中断属于硬件中断**
- 系统调用：运行于核心态，功能大致可分为设备管理、文件管理、进程控制、进程通信、内存管理这五类

**王道习题：**

二轮重做：3 9 18 19 22 26 27 28

大题：
1.
- 解：略
- 答：区分执行态的主要目的是保护系统程序。用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时

2.
- 解：略
- 答：CPU操作与外设传输在时间上的重叠必须有中断和通道技术的支持，原因如下：
    - 通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立于CPU运行，因而做到了输入 / 输出操作与CPU并行工作
    - 中断就是在输入 / 输出结束时，或硬件发生某种故障时，由相应的硬件（即中断机构）向CPU发出信号，这时CPU立即停下工作而转向处理中断请求，待处理完中断后再继续原来的工作
    - 因此，通道技术和中断技术结合起来就可实现CPU与I/O设备并行工作，即CPU启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入/输出操作；当通道工作结束后，再通过中断机构向CPU发出中断请求，CPU则暂停正在执行的操作，对出现的中断进行处理，处理完后再继续原来的工作。这样，就真正做到了CPU与I/O设备并行工作

错题总结：
- 系统调用需要触发trap指令，如基于x86的Linux系统，该指令为int 0x80或sysenter。也就是说，用户程序设计时，使用的中断是内中断，其指令称为访管指令或trap指令
- 时钟中断的主要工作是处理和时间有关的信息及决定是否执行调度程序。和时间有关的所有信息包括系统时间、进程的时间片、延时、使用CPU的时间、各种定时器
- 计算机通过**硬件**机制完成由用户态到核心态的转换，而不是所谓“中断处理程序”，后者一般在核心态执行
- 子程序调用只需保存程序断点，即该指令的下一条指令的地址；中断处理不仅要保存断点(PC的内容)，还要保存程序状态字寄存器（PSW)的内容。**在中断处理中，最重要的两个寄存器是PC和PSWR**
- 当CPU检测到中断信号后，**由硬件自动保存被中断程序的断点(即程序计数器PC)**，之后，硬件找到该中断信号对应的中断向量，中断向量指明中断服务程序入口地址（各中断向量统一存放在中断向量表中，该表由操作系统初始化)。接下来开始执行中断服务程序，**保存PSW、保存中断屏蔽字、保存各通用寄存器的值**，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核
- 事件大总结：
    - *可能在用户态发生的事件：访管指令（只能）；**系统调用**；读时钟指令；取数指令；寄存器清零；跳转指令；设置断点指令；数据传送指令；压栈指令；从内存中取数；将运算结果装入内存；算术运算；命令解释；外部中断；各类异常（如缺页中断、trap指令）*
    - *只能在核心态发生的事件：广义指令（也就是系统调用）；置时钟指令；关中断指令；输入 / 输出；缺页处理；时钟中断处理；进程调度；进程切换；**设备管理、文件管理、进程控制、进程通信、内存管理**（也就是系统调用的细分功能）*

#### b)其他

操作系统发展历程：
- 手工操作阶段→联机批处理→脱机批处理→执行系统（左边三个均为单道批处理系统）→多道批处理系统/分时系统/实时系统→
- 单CPU计算机配置的操作系统：批量操作系统、分时操作系统、实时操作系统、个人计算机操作系统
- 具有并行结构的计算机系统配置的操作系统：网络操作系统（计算机网络，松耦合）、集群操作系统（分布存储的多计算机系统）

操作系统结构：
- 单体结构 / 模块结构：操作系统由多个模块构成，各模块可相互调用。优点：代码执行效率比较高。缺点：规模扩大时，难以维护、调试。操作系统实例：UNIX、Linux
- 层次结构：层次结构是把操作系统划分为若干层，各层之间只能是单向依赖或单向调用关系，这样不但系统结构清晰，而且不构成循环。优点：整体问题局部化，系统的正确性可通过各层正确性来保证。增加、修改或替换层次不影响其他层次，有利于系统的维护和扩充。缺点：层次结构是分层单向依赖的，必须要建立模块（进程）间的通信机制，系统花费在通信上的开销较大，系统的效率也就会降低
![](https://files.catbox.moe/5vd9ka.png)
![](https://files.catbox.moe/d4dgqg.png)
- 微内核构架：分为运行在核心态的微内核和运行在用户态并以C/S方式活动的服务进程。微内核：最基本的核心功能（进程 / 线程管理、低级存储器管理、中断和陷入处理）。优点：扩展性和灵活性、可靠性和安全性、可移植性、可以很好地支持分布式计算。缺点：系统开销大
- 宏内核构架：**主流的操作系统都是基于宏内核的构架，如Windows, Android, iOS, macOS, Linux等，但也广泛吸取了微内核构架的优点**
- 外核：不同于克隆真实机器的另一种虚拟机策略，外核所做的是保持多个虚拟机之间彼此不发生冲突

**操作系统引导（结合第四章学习）：**引导过程如下：
- 1.开机后，CPU加电，初始化(CS) = 0FFFFH，(IP) = 0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条JMP指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。
- 2.初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。
- 3.硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止；如无故障，屏幕会显示CPU、内存、硬盘等信息
- 4.BIOS将控制权交给排在首位的启动设备后，CPU将该设备主引导扇区的内容（主引导记录MBR）加载到内存中，然后由MBR检查分区表，查找活动分区，并将该分区的引导扇区的内容（分区引导记录PBR）加载到内存，执行引导程序（启动管理器）
- 5.加载操作系统

虚拟机：
- 第一类虚拟机管理程序：直接运行在裸机上，是唯一一个运行在最高特权级的程序
- 第二类虚拟机管理程序：运行在宿主操作系统上，自己则是客户操作系统，实际上就像一个普通的进程

错题总结：
- 操作系统的基本类型主要有批处理操作系统、分时操作系统和实时操作系统
- 现代操作系统都是多任务的（主要特点是并发和并行），但并不一定需要运行在多CPU的硬件上，单个CPU也可满足要求
- 甘特图画法：
    - 横坐标上标出合适的时间间隔，纵坐标上的点是程序的名字
    - 过横坐标上每个标出的时间点，向上作垂直于横坐标的虚线
    - 用几种不同的线（推荐用“直线”“波浪线”“虚线”三种，较易区分）代表对不同资源的占用，按照题目给出的任务时间片，平行于横坐标把不同程序对应的线段分别画出来
    - 画图时要注意，如处理器、打印设备等资源是不能让两个程序同时使用的，有一个程序正在使用时，其他程序的请求只能排队。
- 常驻内存的只是操作系统内核，其他部分仅在需要时才调入
- 操作系统的引导程序位于磁盘活动分区的引导扇区中。引导程序分为两种：一种是位于ROM中的**自举程序**（BIOS的组成部分)，用于启动具体的设备；另一种是位于装有操作系统硬盘的活动分区的引导扇区中的**引导程序**（称为启动管理器)，用于引导操作系统
- 虚拟机既可以用软件实现，也可以用硬件实现

#### 本章小结

- 特权指令与非特权指令：
    - 所谓特权指令，是指有特殊权限的指令，由于这类指令的权限最大，使用不当将导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。若所有程序都能使用这些指令，则系统一天死机n次就不足为奇。为保证系统安全，这类指令只能用于操作系统或其他系统软件，不直接提供给用户使用
    - 在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令
- 定义微内核构架OS的四个方面：①内核足够小；②基于C/S模式；③机制与策略分离；④采用面向对象技术

### <a name="12">（二）进程管理</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### a)进程、线程的基本概念以及两者的区别

*程序段 + 相关数据段 + PCB = 进程实体 / 进程映像*

- 进程：进程是进程实体的运行过程，是系统进行**资源分配和调度**的一个独立单位（强调资源）
- 线程：直接的理解就是“轻量级进程”，**它是一个基本的CPU执行单元**，也是程序执行流的最小单位，**是被系统独立调度和分派的基本单位**（强调调度/执行）
    - 线程由线程ID、程序计数器、寄存器集合和堆栈组成
    - 线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可以使用其进程拥有的全部资源
    - 线程也有就绪、阻塞、运行三种基本状态
    - 若线程的切换发生在同一个进程内部，则只需要很少的时空开销
- 进程与线程的区别：
    - 调度：拥有资源的是进程，独立调度的是线程
    - 并发性：线程的并发性更好（因为线程切换时，有可能会发生进程切换，也有可能不发生）
    - 拥有资源：线程只有必不可少、能保证独立运行的资源
    - 独立性：每个进程都拥有独立的地址空间和资源，进程中的线程对其他进程不可见
    - 系统开销：进程开销大，线程开销小，且同一进程中的不同线程之间的同步与通信非常容易实现
- 线程的组织与控制：
    - 线程控制块TCB：包括①线程标识符；②一组寄存器，包括程序计数器、状态寄存器和通用寄存器；③线程运行状态，用于描述线程正处于何种状态；④优先级；⑤线程专有存储区，线程切换时用于保存现场等；⑥堆栈指针，用于过程调用时保存局部变量及返回地址等
    - 一个线程可以读、写甚至清楚同一进程的另一个线程的堆栈
    - 线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。相应地，在操作系统中就有用于创建线程和终止线程的函数（或系统调用）
    - 通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行
- 线程的实现方式：
    - 用户级线程（ULT）（多对一）：内核意识不到线程的存在，使用线程库设计多线程程序。该方式可以使线程切换时不转换到内核空间，节省了模式切换的开销
    - 内核级线程（KLT）（一对一）：又称内核支持的线程，该方式的线程切换比较快、开销小，但同一进程的线程切换仍需要转到核心态进行，系统开销较大
    - 组合方式（多对多）：多内核级线程对多用户级线程（通过时分多路复用实现）（**要求用户级线程的数量大于等于内核级线程的数量**）
    - 线程库的实现方法：
        - 在用户空间提供一个没有内核支持的库
        - 实现由操作系统直接支持的内核级的一个库
        - 目前使用的三种主要线程库为：POSIX Pthreads、Windows API、Java，其中POSIX Pthreads两种方式都支持，Windows支持内核级，Java依靠前两者实现
    

**王道习题：**

一轮标记题：5 7 14 15 20(1, 5) 22 33 38 40 44 47 48 56

二轮重做：1 14 16 26 28 52 56

大题：1 2 5 6
1.
- 答：执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系；并发地执行不同的应用程序时，形成多对多的关系

2.
- 答：父进程创建子进程后，父进程与子进程同时执行（并发）。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行

3.
- 答：**每个进程有自己独立的地址空间。在操作系统和硬件的地址保护机制下，进程无法访问其他进程的地址空间，所以必须借助于操作系统的系统调用函数实现进程之间的通信。**进程通信的主要方式有:
    - 共享内存区。通过系统调用创建共享内存区。多个进程可以（通过系统调用）连接同一个共享内存区，通过访问共享内存区实现进程之间的数据交换。**使用共享内存区时需要利用信号量解决同步互斥问题**
    - 消息传递。通过发送/接收**消息**，系统调用实现进程之间的通信。当进程发送消息时，系统将消息从用户缓冲区复制到内核中的消息缓冲区，然后将消息缓冲区挂入消息队列。进程发送的消息保持在消息队列中，直到被另一进程接收。当进程接收消息时，系统从消息队列中解挂消息缓冲区，将消息从内核的消息缓冲区中复制到用户缓冲区，然后释放消息缓冲区（即直接通信方式）
    - 管道系统。管道是先进先出（FIFO）的信息流，**允许多个进程向管道写入数据，允许多个进程从管道读出数据。**在读/写过程中，操作系统保证数据的写入顺序和读出顺序是一致的。进程通过读/写管道文件或管道设备实现彼此之间的通信。
    - 共享文件。利用操作系统提供的文件共享功能实现进程之间的通信。这时，**也需要信号量来解决文件共享操作中的同步和互斥问题**

4.
- 答：多线程是指在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。多线程与多任务的区别：多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务

5.
- 答：
    - 1) 是。若系统中未运行进程，则系统很快会选择一个就绪进程运行。只有就绪队列中无进程时，CPU才可能处于空闲状态
    - 2) 不一定。因为系统中的所有进程可能都处于等待态，**可能处于死锁状态，**也有可能因为等待的事件未发生而进入循环等待态
    - 3) 不一定。因为高优先级的进程有可能正处在等待队列中，进程调度会从就绪队列中选择一个进程占用CPU，这个被选中的进程可能优先级较低

6.
- 答：
    - 1) 为支持多进程的并发执行，系统为每个进程建立了一个数据结构：进程控制块（PCB），用于进程的管理和控制。PCB中记录了有关进程的一些描述信息和控制信息，包括**进程标识符、进程当前的状态、优先级、进程放弃CPU时的现场信息，以及指示组成进程的程序和数据在存储器中存放位置的信息**、资源使用信息、进程各种队列的连接指针和反映进程之间的隶属关系的信息等
    - 2) 创建、阻塞、唤醒、终止（总之就是没有运行原语）
    - 3) 略，**总之强调两点：①进程状态的转换；②进程PCB的改变**

7.
- 答：
    - 1) 时间片轮转法调度进程策略
    - 2) 
        - 1.进程被调度，获得CPU，进入运行态
        - 2.进程需要读文件，因IO操作进入阻塞态
        - 3.进程打印输出结果，因打印机未结束而阻塞
        - 4.打印机打印结束，进程重新回归就绪态，并排在尾部
        - 5.进程所需数据已从磁盘进入内存，进程回到就绪态
        - 6.运行的进程因为时间片用完而让出CPU，排到就绪队列尾部

错题总结：
- 程序代码经过多次创建可对应不同进程，而**同一个**系统进程（或线程）可以由系统调用的方法被不同的进程（或线程）多次使用
- 只要就绪队列不为空，CPU就总是可以调度进程运行，保持繁忙。这与就绪进程的数目没有关系，除非就绪队列为空，此时CPU进入等待态，导致CPU的效率下降
- 多线程系统可以做到：
    - 利用线程并行地执行矩阵乘法运算
    - Web服务器利用线程响应HTTP请求
    - 基于GUI的调试程序用不同的线程分别处理用户输入、计算和跟踪等操作
- **匿名管道只能用于具有亲缘关系的进程间通信，命名管道可用于同一主机上的任意进程间通信。***管道自带同步与互斥，*且为半双工，数据只能向一个方向流动。需要双方通信时，需要建立起两个管道
- 我们把管道一次最多可以缓存的数据量大小叫做PIPESIZE。内核在处理管道数据的时候，底层也要调用类似read和write这样的方法进行数据拷贝，这种内核操作每次可以操作的数据量也是有限的，一般的操作长度为一个page，即默认为4k字节。我们把每次可以操作的数据量长度叫做PIPEBUF。PIPEBUF的作用是，内核在处理管道的时候，*如果每次读写操作的数据长度不大于PIPEBUF时，保证其操作是原子的。*而PIPESIZE的影响是，大于其长度的写操作会被阻塞，直到当前管道中的数据被读取为止
- **用户级线程的切换可以在用户空间完成，内核级线程的切换需要操作系统帮助进行调度，因此用户级线程的切换效率更高**
- 信箱通信是一种间接通信

#### b)进程控制块、进程的状态与转换

PCB：使参与并发执行的每个程序（含数据）能够独立运行的专门的数据结构。系统唯有通过进程的PCB才能感知到进程的存在。一个PCB实例如下：

进程描述信息|进程控制和管理信息|资源分配清单|处理机相关信息
:-:|:-:|:-:|:-:
进程标识符（PID）|进程当前状态|代码段指针|通用寄存器值
用户标识符（UID）|进程优先级|数据段指针|地址寄存器值
|代码运行入口地址|堆栈段指针|控制寄存器值
|程序的外存地址|文件描述符|标志寄存器值
|进入内存时间|键盘|状态字
|处理机占用时间|鼠标
|信号量使用

- 进程控制：进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，是一个不可分割的基本单位
    - 创建原语：
        - 1）为新进程分配一个唯一的进程标识号，并申请一个空白PCB（PCB是有限的）。**若PCB申请失败，则创建失败**
        - 2）为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现）。这些资源或从操作系统获得，或仅从其父进程获得。**如果资源不足，则并不是创建失败，而是处于创建态，等待内存资源**
        - 3）初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等
        - 4）若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行
        - 允许一个进程创建另一个进程，此时的创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程
    - 进程的终止：①正常结束；②异常结束；③外界干预
    - 进程的阻塞和唤醒：一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。应当注意，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用

- 进程的状态和转换：
    - 运行态：在单处理机中，每个时刻只有一个进程
    - 就绪态：进程在该队列获得了除处理机外的一切所需资源
    - **阻塞态 / 等待态**：可以根据阻塞原因的不同，设置多个阻塞队列
    - 创建态：进程正在创建
    - 结束态：进程正在消失，可能是进程正常结束或其他原因退出运行。进程首先将进程置为结束态，再进一步处理资源释放和回收等工作
    - 转换：图略

#### c)进程同步的基本概念；实现临界区互斥的基本方法；信号量机制及P、V操作；了解经典同步问题，并通过信号量机制解决进程同步问题

进程同步的基本概念：	
- 为什么要引入同步互斥：因为并发进程是异步的，为了协调进程之间的相互制约关系，所以引入同步互斥
- 进程的异步性：由于系统的资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进
- 并发过程执行产生的两种相互制约关系：
    - 同步：进程 A 应在进程 B 之前执行
    - 互斥：进程 A 和进程 B 不能在同一时刻执行
- 临界资源：一次仅允许一个进程使用的资源；如物理设备(打印机)，共享变量，共享数据，共享缓冲区，公用队列
- 共享资源：可用被多个进程同时使用的资源；如可重入代码/纯代码，共享程序段，磁盘，非共享数据
- 临界区：访问临界资源的那段代码。如果n个进程涉及到了同一个变量A，则A的相关临界区 = 访问临界资源A的那段代码 = n个代码段
- 同步机制遵循的准则：
    - 空闲让进：临界区空闲，允许一个进程进入【运行进程访问空闲的临界资源】
    - 忙则等待：有进程进入临界区时，其他进程需等待【两个进程不能同时进入临界资源】
    - 有限等待：请求访问的进程应保证在有限时间内进入临界区【进程等待进入临界区的时间是有限的】
    - 让权等待：进程不能进入临界区时，应该立即释放处理器，防止进程忙等待【不能进入临界区的执行态进程立即放弃CPU】

实现临界区互斥的基本方法：（不是没有考过哦！）
- 软件实现法：
    - 单标志法（必须交替，违背“空闲让进”）
    - 双标志法先检查（进入区有多段代码，可能会导致错误，违背“忙则等待”）
    - 双标志法后检查（同时设置标志，可能会导致“饥饿”现象）
    - Peterson's Algorithm：先双标志法，再单标志，最后检查（不满足“让权等待”）
- 硬件实现法：低级方法 / 元方法
    - 中断屏蔽方法
    - 硬件指令方法：
        - TestAndSet指令：true表示正被占用
        - Swap指令：交换key和lock的值
- 互斥锁（mutex lock）：
    - 定义：解决临界区最简单的工具
    - 特点：通常采用硬件机制实现；常用于多处理器系统
    - 缺点：忙等待
    - 代码：acquire()获取锁，release()释放锁

管程：一个共享类
- 定义：
    - 管程定义了共享数据结构和各种进程在该数据结构上的全部操作
    - 结构类似于Class，把对共享资源的操作封装起来
    - 管程支持进程互斥；任何时候只有一个进程在管程中执行
    - 管程不仅能实现进程间的互斥，还能实现进程间的同步
- 组成：这类题目如果看到是管程外这个字眼，那就是错误的，**管程的组成都是基于管程内部的**
    1. 管程的名字
    2. 局部于管程内部的共享数据结构或者共享变量说明
    3. 对管程内的数据结构进行操作的一组过程
    4. 对局部于管程内部的共享数据设置初始值的语句
- 管程中设置的条件变量	
    - 定义：阻塞原因定义为条件变量condition
    - 有两种操作：
        - x.wait：**阻塞进程，将其插入到阻塞队列中**
        - x.signal：唤醒进程，将其插入到就绪队列中
    - 与信号量的相似点：
        - wait/signal类似于信号量的P/V操作，实现进程的阻塞/唤醒，但不能说和PV操作相同
    - 与信号量的不同点：
        - 条件变量没有值，仅实现“排队等待”功能
        - 信号量有值，这个值反映了剩余资源数

**信号量机制及P、V操作：**
- 信号量的分类：
    - 整型信号量
        - 该信号量被定义为一个用于表示资源数目的整型量S
        - 该机制不遵循“让权等待”的准则
    - 记录型信号量
        - 是一种不存在“忙等”现象的进程同步机制
        - 需要一个用于代表资源数目的整型变量Value
        - 需要一个进程链表L，用于链接所有等待该资源的进程
        - wait操作 = P操作 = 请求一个资源
        - signal操作 = V操作 = 释放一个资源
- P操作（wait）
    - 将信号量值S减1，表示「申请占用一个资源」
	- **如果 s < 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞**
	- 如果 s ≥ 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行
	- 举例：当信号量的值为2时，表示有2个资源可以使用；当信号量的值为-2的时候，表示有两个进程正在等待使用这个资源
- V操作（signal）
    - 将信号量值S加1，表示「释放一个资源」，即使用完资源后归还资源
	- **如果s ≤ 0，表示有某些进程正在等待该资源。由于我们已经释放出一个资源了，因此需要唤醒阻塞进程**
    - S = 0表示没有临界资源可供使用，为什么还要唤醒进程？
        - V操作是先执行S + 1，也就是说，把信号量的值加1后才变成了0
        - 在此之前，信号量的值是-1，即有一个进程正在等待这个临界资源，我们需要唤醒它
- 利用信号量实现同步：
	- 信号量表示资源量：
        - 同步信号量初始值不确定，可以设置
        - 信号量最大值 = 最多可以请求的资源数
        - 信号量最小值 = 最大值 / 初始值 - 最大请求值
    - 步骤：
        - step1：定义一个同步信号量，并初始化为当前可用资源的数量
        - step2：在先执行的操作的「后」面执行 V 操作，释放资源
        - step3：在后执行的操作的「前」面执行 P 操作，申请占用资源
- 利用信号量实现互斥：
    - 信号量表示互斥量：
        - 互斥信号量初始值=1，表示临界区只运行一个进程进入，从而实现互斥
        - 互斥信号量=0，表示临界区已经有一个进程进入，临界区外还没有进程等待
        - 互斥信号量<0，表示临界区中有一个进程
        - 信号量为负数时，其绝对值表示在临界区外等待进入的进程数
    - 步骤：
        - step1：定义一个互斥信号量，并初始化为 1
        - step2：把对于临界资源的访问置于 P 操作和 V 操作之间
        - **P 操作和 V 操作必须成对出现**
        - 缺少 P 操作就不能保证对临界资源的互斥访问
        - 缺少 V 操作就会导致临界资源永远得不到释放、处于等待态的进程永远得不到唤醒

**了解经典同步问题，并通过信号量机制解决进程同步问题：**
- 生产者-消费者问题
```
semaphore mutex = 1; //互斥信号量
semaphore empty = n; //空缓冲区数量
semaphore full = 0; //满缓冲区数量

producer(){
    while(1){
        produce an item in nextp;
        P(empty);
        P(mutex);
        add nextp to buffer;
        V(mutex);
        V(full);
    }
}

consumer(){
    while(1){
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
        consume the item;
    }
}
```
- 复杂的生产者问题（爸爸放苹果，女儿吃苹果，妈妈放橘子，儿子吃橘子）
```
semaphore plate = 1, apple = 0, orange = 0; //有一个盘子、零个苹果、零个橘子

dad(){
    while(1){
        prepare an apple;
        P(plate);
        put the apple on the plate;
        V(apple);
    }
}

daughter(){
    while(1){
        P(apple);
        take the apple from the plate;
        V(plate);
        eat the apple;
    }
}

// mom & son类似。
```

- 读者-写者问题（①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出）
```
int count = 0; //读者数量
semaphore mutex = 1; //保护count变量
semaphore rw = 1; //读写者互斥
semaphore w = 1; //用于实现写优先

writer(){
    while(1){
        P(w);
        P(rw);
        writing;
        V(rw);
        V(w);
    }
}

reader(){
    while(1){
        P(w);
        P(mutex);
        if(count == 0) //一有读者，rw就开P
            P(rw);
        conut ++;
        V(mutex);
        V(w);
        reading;
        P(mutex);
        count --;
        if(count == 0) //最后一个读者了，rw可以V
            V(rw);
        V(mutex);
    }
}

//这里的写进程优先是相对而言的，有些书上把这个算法称为读写公平法，即读写进程具有一样的优先级。当一个写进程访问文件时，若先有一些读进程要求访问文件，后有另一个写进程要求访问文件，则当前访问文件的进程结束对文件的写操作时，会是一个读进程而不是一个写进程占用文件（在信号量w的阻塞队列上，因为读进程先来，因此排在阻塞队列队首，而V操作唤醒进程时唤醒的是队首进程），所以说这里的写优先是相对的

//读者-写者问题有一个关键的特征，即有一个互斥访问的计数器count，因此遇到一个不太好解决的同步互斥问题时，要想一想用互斥访问的计数器count能否解决问题

```

- 哲学家进餐问题（五人五筷）
```
semaphore chopsticks[5] = {1, 1, 1, 1, 1};
semaphore mutex = 1; //取左右筷子的这一整个操作需要一个互斥，免得被抢筷子
Pi(){
    do{
        P(mutex);
        P(chopsticks[i]);
        P(chopsticks[(i + 1) % 5]);
        V(mutex);
        eat;
        V(chopsticks[i]);
        V(chopsticks[(i + 1) % 5]);
        think;
    } while(1);
}
```

- 吸烟者问题（供应商无限地、串行地提供材料，每个吸烟者需要不同的材料）
```
int num = 0;
semaphore offer1 = 0, offer2 = 0, offer3 = 0; //定义信号量，表示三种资源
semaphore finish = 0; //定义信号量，表示抽烟是否完成
Provider(){
    while(1){
        num++;
        num = num % 3;
        if(num == 0){
            put the src;
            V(offer1);
        }
        else if (num == 1){
            put the src;
            V(offer2);
        }
        else{
            put the src;
            V(offer3);
        }
        P(finish);
    }
}

Smoker1(){
    while(1){
        P(offer1);
        make a tobacco and smoke;
        V(finish);
    }
}

// Smoker2 & Smoker3类似
```
- 总结：
    - 生产者-消费者问题：互斥+同步问题
    - 一家人吃水果问题：互斥+同步问题，爸爸+女儿这一连续过程和妈妈+儿子这一连续过程互斥
    - 读者-写者问题：互斥+写优先
    - 哲学家进餐问题：互斥
    - 吸烟者问题：互斥，注意：供应商提供资源，吸烟者制作香烟这一连续过程是彼此互斥的

**王道习题：**

一轮标记题：1 3 9 16 18 20 25 26 28 30 38

二轮重做：43 46 49

大题：
1.
- 答：前两问略。管程的引入是为了解决临界区分散所带来的管理和控制问题。在没有管程之前，对临界区的访问分散在各个进程之中，不易发现和纠正分散在用户程序中的不正确使用P、V操作等问题。管程将这些分散在各进程中的临界区集中起来，并加以控制和管理，管程一次只允许一个进程进入管程内，从而既便于系统管理共享资源，又能保证互斥

2.
- 答：互斥；互斥；同步；同步

3 ~ 7.
- 11-08做

错题总结：
- 可重入代码 / 纯代码：一种允许多个进程同时访问的代码；如进程映像中的共享程序段
- PV操作实现的同步的S的初值由用户确定；如果期望的信息还没发送，则对应的初值为0，若信息已存在，则初值为非0的正数；PV操作实现的互斥的S的初值=1
- 判断代码中的语句是否要互斥执行，可以从以下几个方面考虑【见王道书P121第43题】
    - 不同范围的变量不需要互斥（如进程A和进程B都有变量x，这是两个不同范围的变量，不用互斥）
    - 对变量赋值前，都有声明语句的话，不需要互斥（如「int a; a=1; int a; a=2」，a=1和a=2不需要互斥）（说明是局部变量？）
- 在实现临界区互斥时，“让权等待”准则不一定非得实现，如皮特森算法

#### d)进程间通信，包括共享存储系统、消息传递系统、管道

- 进程间通信：进程通信是指进程之间的信息交换。**PV操作是低级通信方式**，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类：
    - 共享存储：
        - 共享存储又分为两种：低级方式的共享是基于数据结构的共享，高级方式的共享则是基于存储区的共享
        - 对共享空间进行读/写操作时需要使用同步互斥工具
        - 让两个进程共享空间需要通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的
    - 消息传递：
        - 进程间的数据交换以**格式化的消息（Message）**实现
        - 进程通过系统提供的发送消息和接收消息两个原语进行数据交换
        - 通信过程对用户透明，简化了通信程序的设计，是当前应用最广泛的进程间通信机制
        - 微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制
        - 该机制很好地支持多处理机系统、分布式系统、计算机网络
            - **直接通信方式**：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息
            - **间接通信方式**：发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息，这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中
    - 管道通信：
        - 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件
        - 以**字符流形式**传输，只支持**半双工通信**
        - 管道机制必须提供三方面的协调能力：互斥、同步、确定对方的存在
        - 管道可以克服使用文件进行通信的两个问题：
            - 管道的大小是受限的
            - 管道满，写阻塞；管道空，读阻塞
        - 管道内部已经实现同步机制，能够保证数据一致性（保证数据的安全性，在写数据的时候不会被别人读，不会发生二义性）

#### e)进程调度的基本准则；典型调度算法：先来先服务调度算法、短作业(短进程、短线程)优先调度算法、时间片轮转调度算法、优先级调度算法

调度的概念：
- 基本概念
	- 调度是处理机进行分配，即从**就绪队列**中按一定算法（公平，高效的原则）选择一个进程并将处理机分配给他运行，以实现进程并发地执行
	- 调度是多道程序OS的基础；调度是OS设计的核心问题
- 高级调度/作业调度
    - 是**内存与辅存的调度**，从后备队列中调度作业
    - 每个作业只调入调出一次
    - 通常存在于多道批处理系统中
    - 内存与磁盘之间交换数据的转态转换：就绪态到挂起态（408不考挂起）
- 中级调度/内存调度
    - 目的是提高内存利用率和系统吞吐量
    - **将暂时不能运行的进程调到外存等待，设为挂起态**，最后修改状态为就绪态，挂在就绪队列上
    - 是存储器管理中的对换功能
- 低级调度/进程调度
    - 从就绪队列中选取一个进程，调用频率很高
    - 各种OS都必须配置这种调度
- 三种调度的联系
    - 作业调度为进程活动做准备，进程调度使进程正常活动
    - 中级调度将暂时不能运行的进程挂起，中级调度处于另外两个调度之间
    - 调用频率：作业调度 < 内存调度 < 进程调度
    - 进程调度是最基本的，不可或缺
- 易错点：
	- 作业是用户提交的，以用户任务为单位
	- 进程是系统自动生成的，以操作系统控制为单位
	- 进程的调度就是把一个进程从就绪态转换为了运行态

**调度的目标：**
- CPU利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间)
- 系统吞吐率：单位时间内CPU完成作业的数量
- *周转时间：指从作业提交到完成所经历的时间*
    - 周转时间 = 作业完成时间 - 作业提交时间
    - 平均周转时间 = (作业1的周转时间 + ... + 作业n的周转时间) / n
    - 带权周转时间 = 作业周转时间 / 作业实际运行时间
    - 平均带权周转时间 = (作业1的带权周转时间 + ... + 作业n的带权周转时间) / n
- *等待时间：进程等待时间之和，处理机调度算法的主要影响指标*
- *响应时间 = 系统响应时间 - 作业提交时间，该指标在交互式系统里很重要*
- 调度最终目标要考虑的元素：**特定用户的要求 + 系统整体效率 + 调度算法的开销**

调度的实现：
- 调度器：用于调度和分派CPU的组件
    - 排队器：按策略给就绪进程排出一个或多个队列
    - 分派器：从就绪队列中取出进程，并分配CPU
    - 上下文切换器：在对处理机进行切换时，会发生两对上下文的切换操作（原进程→分派器，分派器→新进程）（这个一般不考）
    - 通常采用两组寄存器，其中一组供内核使用，一组供用户使用
- 调度的时机：
	- 不能进行调度与切换的情况：
        - 在处理中断的过程中
        - 进程在OS内核临界区中
        - 其他需要完全屏蔽中断的原子操作过程中
    - 可以进行调度与切换的情况：
        - 发生引起调度条件且当前进程无法继续进行下去时（非剥夺调度）
        - 中断处理结束或自陷处理结束后，被置上请求调度标志（剥夺方式的调度）
- 调度方式：非抢占调度方式、抢占调度方式

**典型的调度算法：**
- FCFS（先来先服务）调度算法：
    - 既可用于作业调度，也可用于进程调度
    - 属于不可剥夺算法
    - 对长作业比较有利，对短作业比较不利
- SJF（短作业优先）/ SPF （短进程优先）调度算法：
    - 对长作业很不利，甚至可能会导致“饥饿”现象
    - 选择的作业时间是用户估计时间，选择的进程时间是系统估计的运行时间
    - 该算法的平均等待时间和平均周转时间最少
- 优先级调度算法：
    - 适合实时操作系统
    - 既可用于作业调度，也可用于进程调度
    - 可分为非抢占式优先级调度和抢占式优先级调度
    - 根据优先级是否可以改变，可分为静态优先级和动态优先级
    - 优先级设置原则：
        - 系统进程优先于用户进程
        - 交互型进程优先于非交互型进程
        - I/O型进程优先于计算型进程
- 高响应比优先调度算法：FCFS + SJF
    - 主要用于作业调度
    - *响应比Rp = (等待时间 + 要求服务时间) / 要求服务时间*
    - 作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业，因而类似于SJF
    - 要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而类似于FCFS
    - 对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，也可获得处理机，克服了“饥饿”现象
- 时间片轮转调度算法：
    - 适合分时系统
	- 若时间片过大，退化为FCFS
	- 若时间片过小，则切换频繁，处理机开销增大
    - 时间片的大小应选择适当，时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力
- 多级队列算法：设置多个就绪队列，不同队列使用不同的调度算法
- 多级反馈队列调度算法：FCFS + 优先级 + 时间片
    - 1. 设置多个就绪队列，并为每个队列赋予不同的优先级（优先级算法）
    - 2. 赋予各个队列的进程运行时间片的大小各不相同（时间片轮转）
    - 3. 每个队列都采用FCFS算法（FCFS）

属性|FCFS|SJF|高响应比|时间片轮转|多级反馈队列
:-:|-|-|-|-|-
可抢占？|**×**|√|√|√|队列内算法不一定
不可抢占？|√|√|√|×|队列内算法不一定
优点|公平且实现简单|平均等待时间最少，效率最高|兼顾长短作业，满足短作业优先且不会发生饥饿现象|兼顾长短作业，为了多个用户能及时干预系统，绝对可抢占的|兼顾长短作业，有较好的响应时间，可行性强
缺点|不利于短作业|长作业会饥饿，估计时间不易确定|计算响应比的开销大|平均等待时间最长，上下文切换浪费时间|无
适用于|无|作业调度，批处理系统|无|分时系统，人机交互系统|相当通用，大家都满意的算法
默认决策模式|非抢占|非抢占|非抢占|抢占|抢占

进程切换的实现：对于通常的进程而言，其创建、撤销及要求由系统设备完成的IO操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，**任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的**

模式切换与上下文切换的区别：模式切换时，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性

调度和切换的区别：调度是指决定资源分配给哪个进程的行为，**是一种决策行为**；切换是指实际分配的行为，**是执行行为**。一般来说，先有资源的调度，然后才有进程的切换

**王道习题：**

一轮标记题：1 3 17 22 26 35

二轮重做：3 32(注意调度切换时间要算上) 

大题：1 6 7 8 9 12
1.
- 答：多级反馈队列调度算法能较好地满足各种类型用户的需要。对终端型作业用户而言，由于它们提交的作业大多属于交互型作业，作业通常比较短小，**系统只要能使这些作业在第1级队列所规定的时间片内完成，便可使终端型作业用户感到满意**；对于短批处理作业用户而言，它们的作业开始时像终端型作业一样，若仅在第1级队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间，对于稍长的作业，**通常也只需要在第2级队列和第3级队列中各执行一个时间片即可完成，其周转时间仍然较短**；对于长批处理作业用户而言，它们的长作业将依次在第1,2,...,n级队列中运行，然后按时间片轮转方式运行，**用户不必担心其作业长期得不到处理**

2.
- 答：略

3 ~ 6、10.
- 解：画好甘特图就不难

7.（注意，是优先数越小，优先级越高！）
- 答：具有两道作业的批处理系统，内存只存放两道作业，它们采用抢占式优先级调度算法竞争CPU，而将作业调入内存采用的是短作业优先调度。8:00，作业1到来，此时内存和处理机空闲，作业1进入内存并占用处理机；8:20，作业2到来，内存仍有一个位置空闲，因此将作业2调入内存，又由于作业2的优先数高，相应的进程抢占处理机，在此期间8:30作业3到来，**但内存此时已无空闲，因此等待**。直至8:50，作业2执行完毕，此时作业3、4竞争空出的一道内存空间，作业4的运行时间短，因此先调入，但它的优先数低于作业1，因此作业1先执行。到9:10时，作业1执行完毕，再将作业3调入内存，且由于作业3的优先数高而占用CPU

8.
- 解：
    - 可抢占式SJF：P1 - P2 - P4 - P1 - P3，平均周转时间为13
    - 时间片轮转算法按就绪队列的FCFS进行轮转，**在时刻2，P被挂到就绪队列队尾，队列顺序为P2, P3, P1，此时P4还未到达**

9.
- 答：
    - 1) 6%
    - 2) (1次调度 + 1次切换) / 一个时间片，答案为1.5%。注意题设问的是切换消耗，所以分子不需要加中断的消耗
    - 3) 为提高CPU的效率，一般情况下要尽量减少时钟中断的次数，如由每秒120次降低到100次，以延长中断的时间间隔。或将每个时间片的中断数量（时钟数）加大，如由24个中断加大到36个。也可优化中断处理程序，减少中断处理开销，如将每次500μs的时间降低到400μs。若能这样，则时钟中断和进程切换的总开销占CPU的时间比为(36×400μs + 1ms + 2ms) / (1/100 × 36) ≈ 4.8%

11.
- 解：
    - 1) J1: 10:00~10:35; J4: 10:35~10:55; J2:10:55~11:25; J5: 11:25~11:55; J3:11:55~12:40
    - 2) 75min

12.
- 解：
    - 1) nice值较大的进程可能会始终无法得到调度，产生“饥饿”现象
    - 2) nice + (1 + cpuTime) / (1 + waitTime); 处于就绪态时，waitTime定时加1，该值会逐渐减小
- 答：
    - 2) nice + k1 * cpuTime - k2 * waitTime

错题总结：
- 该类题型的做法，依旧是画甘特图较为行之有效
- 时间片轮转增加了系统开销，所以不会使得系统高效运行
- 所谓CPU繁忙型，是指该类作业需要大量的CPU时间进行计算，其定义更接近于长作业。FCFS有利于CPU繁忙型的作业，而不利于IO繁忙型的作业
- UNIX属于分时操作系统
- 中断向量本身是用于存放中断服务例行程序的入口地址，而中断向量的地址应是该入口地址的地址（也就是地址从0开始的一系列中断向量）
- 抢占式的短作业优先算法 = “**最短剩余时间**优先算法”（SRTN）
- 注意时间片轮转算法的就绪队列在最开始时的轮转调度，极易出错！

#### f)死锁的形成原因与必要条件；死锁预防、死锁避免、死锁检测和解除

死锁的形成原因与必要条件:
- 为什么会出现死锁？
	1. 系统资源的竞争【空间上】	
        - 系统中不可剥夺资源不足以满足多个进程
		- 只有对不可剥夺资源（如磁带机，打印机）的竞争才可能产生死锁
	2. 进程推进顺序非法【时间上】	
        - 进程运行时，请求和释放资源的顺序不当
		- 系统对独占资源分配不当
    3. 系统资源不足不是系统产生死锁的原因，资源不足只会对进程造成“饥饿”
- 产生死锁的必要条件
	- 互斥条件：多个线程不能同时使用同一个资源
	- 不剥夺条件：进程A已经拥有资源1，在自己使用完之前不能被其他进程获取
	- 请求并保持条件：进程A已经有资源1，想申请资源2，但是资源2被进程B持有，进程A处于等待状态，但是进程A不释放资源1
	- 循环等待条件：两个线程获取资源的顺序构成了环形链（注意，有环形链不代表就是死锁！）

**死锁预防、死锁避免、死锁检测和解除：**
- 死锁预防	
名称|特点|举例
:-:|-|-    
破坏互斥条件|缺点：如打印机等临界资源只能互斥使用|该方法不太可行
破坏不剥夺条件|常用于状态易于保存和恢复的资源（CPU的寄存器和内存资源）|**剥夺资源法**
破坏请求并保持条件|可能会导致饥饿现象|**一次性分配策略、静态分配策略**
破坏循环等待条件|可采用顺序资源分配法，但是编号必须相对稳定，限制了新类型设备的增加|**资源有序分配策略**
- 死锁避免	
    - 系统安全状态：死锁包含在不安全状态之中（系统处于安全状态时，一定无死锁；系统处于不安全状态时，不一定出现死锁）
    - 银行家算法
    0. Column: Available(Work) Max(Only used in step 1) Allocation Need
    1. Need = Max - Allocation（先算Need）
    2. Request ≤ Need & Request ≤ Available?（第一次检测）
    3. Try: Available -= Request, Allocation += Request, Need -= Request（该减减，该加加）
    4. Safety test: Work = Available, while(Work ≥ Need) {Work += Allocation}（第二次检测）
    - 具体到画表，推荐画三列：Allocation、Need、Available(Work)
    - **死锁避免时不会限制用户申请资源的顺序；**需要进程运行所需资源总量信息；不会给可能导致死锁的进程分配资源
- 死锁的检测
    1. 资源分配图：资源分配图是一个有向图，用于表示某时刻系统资源与进程之间的状态。**圆圈代表进程，框代表一类资源；从进程到资源的边叫做请求边；从资源到进程的边叫做分配边**
    2. 死锁定理：S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的
- 死锁的解除
    1. 资源剥夺法：挂起某些死锁进程，并抢占它的资源
    2. 撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源
    3. 进程回退法：让一个或多个进程回退到足以回避死锁的地步
- 各个策略的比较：
名称|资源分配策略|各种可能模式|主要优点|主要缺点
-|-|-|-|-
死锁预防|保守，宁可资源闲置|一次请求所有资源，资源剥夺，资源按序分配|适用于突发式处理的进程，不必进行剥夺|效率低，进程初始化时间延长；剃夺次数过多；不便灵活申请新资源
死锁避免|是“预防”和“检测”的折中（在运行时判断是否可能死锁）|寻找可能的安全允许顺序|不必进行剥夺|必须知道将来的资源需求；进程不能被长时间阻塞
死锁检测|宽松，只要允许就分配资源|定期检查死锁是否己经发生|不延长进程初始化时间，允许对死锁进行现场处理|通过剥夺解除死锁，造成损失

**王道习题：**

二轮重做：18 21 22

大题：（死锁是没考过大题的）
1.
- 答：2 > 1 > 3

2.
- 答：系统会死锁。因为对两个账户进行加锁操作是可以分割进行的，若此时有两个用户同时进行转账，P先对账户A进行加锁，再申请账户B；P先对账户B进行加锁，再申谓账户A，此时产生死锁。解决的办法是：可以采用资源顺序分配法对A、B账户进行编号，用户转账时只能按照编号由小到大进行加锁；也可采用资源预分配法，要求用户在使用资源前将所有资源一次性申请到

3.
- 答：略

4.
- 解：不发生死锁要求，**必须保证至少有一个进程能得到所需的全部资源并执行完毕，m ≥ n * (k - 1) + 1时，一定不会发生死锁**

5.
- 解：略

6.
- 解：
    - 1) 安全，例如P2, P3, P4, P1
    - 2) P2, P3, P4, P1
    - 3) **若2)中的两个请求立即得到满足，则此刻系统并未立即进入死锁状态，因为这时所有的进程未提出新的资源申请，全部进程均未因资源请求没有得到满足而进入阻塞态。只有当进程提出资源申请且全部进程都进入阻塞态时，系统才处于死锁状态**

7 ~ 8.
- 解：略

9.（加入改错本）
- 解：见改错本

错题总结：
- 王道的21题较难，被称作“单行线问题”，说是单行线，其实是在说“两个方向都能通行，但一边要等另一边的车通行完的单行线”

#### 本章小结

- 死锁与饥饿：
    - 一组进程处于死锁状态是指组内的每个进程都在等待一个事件，而该事件只可能由组内的另个进程产生。这里所关心的主要是事件是资源的获取和释放
    - 与死锁相关的另一个问题是**无限期阻塞（Indefinite Blocking）或饥饿（Starvation）**，即进程在信号量内无穷等待的情况
    - 产生饥饿的主要原因是：在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。有时**资源分配策略可能是不公平的**，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推进和响应带来明显影响时，称发生了进程“饥饿”，当“饥饿”到一定程度的进程所赋予的任务即使完成也不再具有实际意义时，称该进程被“饿死”
    - “饥饿”并不表示系统一定会死锁，但至少有一个进程的执行被无限期推迟。“饥饿”与死锁的主要差别如下:
        1. 进入“饥饿”状态的进程可以只有一个，而因循环等待条件而进入死锁状态的进程却必须大于等于两个
        2. **处于“饥饿”状态的进程可以是一个就绪进程，如静态优先权调度算法时的低优先权进程，而处于死锁状态的进程则必定是阻塞进程**

## <a name="16">计算机网络</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

### <a name="17">（一）计算机网络概述</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### (1)计算机网络定义与分类

计算机网络：一般认为，计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统

计算机网络的组成：
- 从组成部分上看，由硬件、软件、协议三大部分组成
- 从工作方式上看，分为边缘部分和核心部分
- 从功能组成上看，由通信子网和资源子网组成，通信子网 = 各种传输介质 + 通信设备 + 相应的网络协议，资源子网 = 实现资源共享功能的设备 + 相应软件

计算机网络的功能：1.数据通信（最基本和最重要的功能）；2.资源共享；3.分布式处理；4.提高可靠性；5.负载均衡（即：将工作任务均衡分配）

计算机网络的分类：
- 按分布范围分：1.广域网（WAN）2.城域网（MAN）3.局域网（LAN）4.个人区域网（PAN）
- 按传播技术分：1.广播式网络：局域网、广域网中的无线和卫星通信网络；2.点对点网络，采用分组存储转发与路由选择机制
- 按拓扑结构分：主要分为总线形、星形、环形和网状网络等，前三者多用于局域网，网状网络多用于广域网
- 按使用者分：分为公用网和专用网
- 按交换技术分：1.电路交换网络（典型：传统电话网络）；2.报文交换网络（又称存储-转发网络）；3.分组交换网络（又称包交换网络，现在的主流网络基本都是这种）
- 按传输介质分：分为有线和无线两大类

计算机网络的性能指标：
- 带宽：在计算机网络中，是“最高数据传输速率”的同义语，单位是比特/秒
- 时延：由发送时延（分组长度/信道带宽）、传播时延（信道长度/电磁波在信道上的传播速率）、处理时延（存储转发时的处理时间）、排队时延（进入路由器时要排队）组成，后两者一般可忽略不计
- 时延带宽积 = 传播时延 × 信道带宽
- 往返时延：指从发送端发出一个短分组，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延
- 吞吐量（Throughput）：单位时间内通过某个网络（或信道、接口）的数据量
- 速率：也称数据传输速率、数据率或比特率
- 信道利用率 = 有数据通过时间 / （有 + 无）数据通过时间

**王道习题：**

一轮标记题：6 10 12 16 18

二轮重做：3 16 18

大题：1 5 6
1.
- 解：101000B，25000B，10000B；

2.
- 解：80Mb/s，409.6Mb/s

3.
- 解：略
- 答：如果网络容易丢失分组，那么对每个分组逐一进行确认较好，此时仅重传丢失的分组。另一方面，如果网络高度可靠，那么在不发生差错的情况下，仅在整个文件传送的结尾发送一次确认，从而减少了确认次数，节省了带宽。不过，即使只有单个分组丢失，也要重传整个文件。

4.
- 解：电路：s + x / b + k * d；分组：设共有n个分组，则n * p / b + (k - 1) * p / b + k * d
- 解析：**计算分组交换的时延时，我们可以从最后一个分组的视角进行考虑，它首先需要排队等n次传播时延，然后又需要经过k次传播时延和k-1次中间结点的传输时延**

5.
- 解：t = (x / p + k - 1) * (p + h) / b，t对p求导，得p = √((xh)/(k-1))

6.
- 解：
    - 1)2RTT + 1000 * 1024 * 8 / (1.5 * 10 ^ 6) + 0.5RTT = 0.2 + 5.46 + 0.05 = 5.71s
    - 2)5.71 + 999RTT = 105.61s
    - 解析：**最后一个分组虽然没有确认，但此时已经满足题设要求的“直到文件的最后一位到达目的地”了**
    - 3)2RTT + 49RTT + 0.5RTT = 5.15s

7.
- 解：略
- 答：不相同。在报文流中，网络保持对报文边界的跟踪；而在字节流中，网络不进行这样的跟踪。例如，一个进程向一条连接写了1024B，稍后又写了1024B，那么接收方共读了2048B。对于报文流，接收方将得到两个报文，每个报文1024B。而对于字节流，报文边界不被识别，接收方将全部2048B作为一个整体，在此已经体现不出原先有两个不同报文的事实

错题总结：
- 广播式网络共享广播信道（如总线)，通常是局域网的一种通信方式（局域网工/在数据链路层)，因此不需要网络层，因而也不存在路由选择问题。但数据链路层使用物理层的服务必须通过服/访问点实现
- ARPAnet是最早的计算机网络，它是因特网的前身

#### (2)计算机网络体系结构

计算机网络体系结构：计算机网络各层及其协议的集合

*n-SDU + n-PCI = n-PDU = (n-1)-SDU*

协议：由语法、语义和同步三部分组成，语法规定了传输数据的格式，语义规定了所要完成的功能，同步规定了执行各种操作的条件、时序关系等

接口：同一结点内相邻两层间交换信息的连接点。在典型的接口上，同一结点相邻两层的实体通过SAP进行交互。**物理层的服务访问点就是网卡接口，数据链路层的服务访问点是MAC地址，网络层的服务访问点是IP地址，传输层的服务访问点是端口号，应用层提供的服务访问点是用户界面**

服务：下层为紧邻的上层提供的功能调用，上层与下层之间交换的命令称为服务原语
- 服务原语：请求（Request）（C->S）、指示（Indication）（S->C）、（对请求的）证实（Confirmation）（S->C）、（对指示的）响应（Response）（C->S），无应答服务只有前两者
- 注意：**协议是“水平”的，但服务是“垂直”的**
- 注意：**只有能被上层看到的功能，才能算得上是服务！**
- 服务的分类：
    - 面向连接服务和无连接服务
    - 可靠服务和不可靠服务
    - 有应答服务和无应答服务

OSI参考模型：**有7层**，自下而上依次为**物理层、数据链路层、网络层、传输层、会话层、表示层、应用层**，低三层统称为通信子网，传输层承上启下，高三层统称为资源子网。其中，会话层允许不同主机上的各个进程之间进行会话，表示层主要处理在两个通信系统中交换信息的表示方式，应用层为特定类型的网络应用提供访问OSI参考模型环境的手段

TCP/IP模型：APRA在研究APRAnet时提出了TCP/IP模型，从低到高依次为**网络接口层、网际层、传输层和应用层**，并由于得到了广泛应用而成为事实上的国际标准

两个模型的对比：
- 相似之处：都采取分层的体系结构；都基于独立的协议栈；都可以解决异构网络的互联问题；
- 差别：
    - OSI精准地定义了服务、协议和接口三个概念，与面向对象思想非常吻合
    - OSI通用性良好，TCP/IP则不适合于非TCP/IP的协议栈
    - TCP/IP在设计之初就考虑到了多种异构网的互联问题，OSI是后来加上的
    - 主要考察点：**OSI在网络层就支持无连接和面向连接的通信，在传输层仅有面向连接的通信，而TCP/IP则选择了更省钱的做法**

**王道习题：**

二轮重做：1 8 12 13 

大题：

2.
- 解：物理层；网络层；数据链路层；应用层；会话层

错题总结：
- 在OSI参考模型中，会话层的两个主要服务是会话管理和同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信，实现数据同步
- 在OSI参考模型中，**2、3、4层均提供差错控制、流量控制等功能，3、4层均提供拥塞控制功能**

### <a name="18">（二）物理层</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### (1)物理层的基本概念

- 物理层解决了什么？
	- 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。
- 物理层主要任务？
	- 确定与传输媒体接口有关的一些特性
- 与传输媒体接口有关的特性？
	- 机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况
	- 电气特性：规定传输二进制时，线路上信号的**电压范围**，阻抗匹配、传输速率和距离限制。如某网络在物理层规定，信号的电平用+10V ~ +15V表示二进制0，用-10V ~ -15V表示二进制1，电线长度限于15m之内，这些都是电气特性
	- 功能特性：指明某条线上出现的某一电平的**电压表示何种意义**。注意与电气特性区分，如描述一个物理层接口引脚处高电平时的含义表示的是功能特性
    - 过程特性：指明对于不同功能的各种可能事件的出现顺序
- 物理层协议也称物理层接口标准，或物理层规程（Procedure）
- 常用的物理层接口标准：EIA RS-232-C、ADSL、SONET/SDH、EIA/TIA RS-449、CCITT的X.21等

**物理层设备：**
中继器：
- 中继器的功能：对信号再生和还原（而非简单地将衰减的信号放大），保持与原数据相同，以增加信号传输的距离，延长网络的长度
- 中继器的两端
	- 中继器两端的网络部分是网段，而不是子网，使用中继器连接的几个网段**仍然是一个局域网**
    - **中继器没有存储转发功能，因此它不能连接两个速率不同的网段，中继器两端的网段一定要使用同一个协议**
- 5-4-3规则
	- 网络标准中对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。
    - 采用粗同轴电缆的10BASE5以太网规范中，4个中继器，串联5段通信介质，只有3段可以挂接计算机，其余2段只能用作扩展通信范围的链路段
集线器：
- 本质是一个多端口的中继器
- 集线器功能
	- 对信号进行再生放大转发
	- 端口收到数据后，从除输入端口外的所有端口转发出去
    - 不具备信号的定向传送能力，是一个共享设备

**王道习题：**

一轮标记题：2 3 8

二轮重做：7

#### (2)数据通信的基础知识

基础知识：
- 数据：传送信息的实体，通常是有意义的符号序列
- 信号：数据的电气 / 电磁的表现，是数据在传输过程中的存在形式
    - 数字信号（离散信号）：代表消息的参数取值是离散的
    - 模拟信号（连续信号）：代表消息的参数取值是连续的
- 信源：产生或发送数据的源头
- 信宿：接收数据的终点
- 信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条信道
- 信道分类：
    - 按传输信号：模拟信道用于传输模拟信号；数字信道用于传输数字信号
    - 按传输介质：无线信道、有线信道
- 信号分类：
    - 基带信号：将数字信号1和0直接用两种不同的电压表示，然后送到数字信道上传输（基带传输）
    - 宽带信号：将基带信号进行调制后形成频分复用模拟信号，然后送到模拟信道上传输（宽带传输）
- 通信方式：
    - 单工通信：
        - 单向通信。即只能有一个方向的通信而没有反方向的交互
        - 如无线电广播、有线电广播
    - 半双工通信：
        - 双向交替通信。即通信双方都可以发送信息，但不能双方不能同时发送
        - 这种方式是一方发送另一方接收
    - 全双工通信
        - 双向同时通信。即通信双方可以同时发送或接收信息
        - 单工通信需要一条信道，而半双工通信和全双工通信需要两条信道
- 数据传输方式：
    - 串行传输	
        - 1比特1比特地按照时间顺序传输
        - 速度慢，费用低，适合远距离
    - 并行传输	
        - 若干比特通过多条通信信道同时传输
        - 速度快，费用高，适合近距离
        - 适用于计算机内部数据传输



- 码元：码元是指用一个**固定时长**的信号波形（数字脉冲）表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。1码元可以携带若干比特的信息量
    - 在使用二进制编码时，只有两种不同的码元，一种代表0状态，一种代表1状态，是二进制码元
    - 一个码元所携带的信息量是不固定的，是由调制方式和编码方式决定的
- 速率 && 波特
    - 1波特表示数字通信系统每秒传输一个码元
    - **码元传输速率 = 码元速率 = 波特率 = 波形速率 = 符号速率 = 调制速率**：表示单位时间内数字通信系统所传输的码元个数（也可以称为脉冲个数或信号变化的次数），单位是波特（Baud）
    - **信息传输速率 = 信息速率 = 比特率**：表示单位时间内数字通信系统传输的二进制码元个数（或者比特数），单位：b/s
    - 关系：波特率 = 比特率 / 每码元所含比特数
    - 信道的**极限容量**是指信道的最高码元传输速率或信道的极限信息传输速率



**奈氏准则 & 香农定理：**
- 码间串扰：信号中的许多高频分量往往不能通过信道，否则在传输中会衰减，导致接收端收到的信号波形失去码元之间的清晰界限
- 影响失真程度的因素：码元传输速率、信号的传输距离、噪声干扰、传输媒体的质量
- 奈氏准则 / 采样定理 / 奈奎斯特定理：
	- **在理想低通（无噪声、带宽有限）的信道中，为了避免码间串扰，极限码元传输速率为2W Baud**（W是信道带宽，单位是Hz）
	    - **带宽只有在奈氏准则和香农定理中单位是HZ，其余都是b/s**
        - 理想低通信道下的极限数据传输率 = 2W *log2V（W是信道带宽，单位：Hz。V是码元的离散电平数目，即共有几种码元）
    - 在任何信道中，码元传输速率是有上限的，如果传输速率超过这个上限，就会出现严重的码间串扰问题，使接收端对码元的识别成为不可能
    - 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高速率传送码元而不出现码间串扰
    - 由于码元的传输速率受奈氏准则的制约，所以**要提高数据的传输速率，就必须设法使每个码元能携带更多的个比特量的信息**
- 香农定理：
	- **在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输率有上限值**
    - 信噪比
        - 信号的平均功率和噪声的平均功率之比，常记于S/N，并用分贝（dB）作为度量单位
        - 信噪比（dB） = 10 lg(S/N) (dB)
    - 信道的极限数据传输速率 = W log2(1+S/N) (b/s)
    - 信道的带宽越大或信道的信噪比越大，则信息的极限传输速率就越高
    - 对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了
    - **只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错传输**

**编码与调制：**
- **编码：数据→数字信号；调制：数据→模拟信号**
- 信号是数据的具体表示形式，它和数据有一定的关系，但又和数据不同。数字数据可以通过**数字发送器**转换为数字信号传输，也可以通过**调制器**转换成模拟信号传输；同样，模拟数据可以通过**PCM编码器**转换成数字信号传输，也可以通过**放大器调制器**转换成模拟信号传输。这样，就形成了4种编码方式
- **基带信号 & 带通信号：**
    - 基带信号：**来源于信源的信号。**将数字信号1和0直接用两种不同的电压表示，再送到数字信道上传输（基带传输）
        - 计算机输出的代表各种文字或图像文件的数据信号都属于基带信号
        - 基带信号就是发出的直接表达了要传输的信息的信号。如说话的声波就是基带信号
	    - 基信号往往包含较多带的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这个问题，就必须对基带信号进行调制
    - 带通信号：**经过载波调制后的信号（即仅在一段频率范围内能通过信道）**
- **基带调制 & 带通调制：**
    - 基带调制：
        - 仅仅对基带信号的波形进行变换，使它能够与信道特性相适应
        - 经过变换后的信号仍然是基带信号
        - **由于基带调制是把数字信号从一种形式转换为另一种形式的数字信号，所以这种过程又称为编码**
    - 带通调制：
        - 使用载波进行调制，**把基带信号的频率搬移到更高的频段，并转换为模拟信号**，这样就可以更好地在模拟信道中传输
- 数字数据**编码为**数字信号
	- 归零编码（RZ）
        - 信号电平在一个码元之内都要恢复到零的编码方式
		- 这种编码在传输过程中处于低电平的情况多，信道利用率低
	- 非归零编码（NRZ）
        - 正电平为1，负电平为0
		- 编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步
		- 需要在接收方和发送方另外建立一条信道来传输时钟周期信号来保证同步，无法保证自同步
		- **只有非归零编码不含同步信息**
	- 反向不归零编码（NRZI）
        - 信号电平翻转表示0，信号电平不变表示1
		- 反向不归零编码对于全部是1的信号同样难以确认一共发送了多少个信号，同样需要在收发双方之间另外建立一条信道传输时钟周期信号，无法实现自同步
	- **曼彻斯特编码**
        - **前高后低表示1，前低后高表示0**
		- 该编码特点是在每一个码元的中间出现电平跳变，位中间的跳变既作为时钟信号（可用于同步），又作为数据信号
		- **所占的频带宽度是原始的基带宽度的两倍，即每个码元都被调成两个电平，所以数据传输速率只有波特率的1/2**（在一个时钟周期内电平变化了两次，而只传输了一位比特），编码效率为50%
        - **以太网使用的编码方式就是曼彻斯特编码**
	- 差分曼彻斯特编码	
        - 若码元为1，则前半个码元的电平与上一个码元的电平相同，若为0，则相反。（**前同后异为1，前异后同为0**）
		- 该编码的特点是在每个码元中间都有一次电平的跳转，可以实现自同步，且抗干扰强于曼彻斯特编码。
	- 4B/5B编码：
        - 比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B，编码效率为80%
        - 5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他16种作为控制码（帧的开始和结束、线路的状态信息等）或保留
- 数字数据**调制为**模拟信号
    - 1）幅移键控（ASK）：调幅
    - 2）频移键控（FSK）：调频
    - 3）相移键控（PSK）：调相
    - 4）正交振幅调制（QAM）：在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B，采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输速率R为 R= B log2(mn) (b/s)
- 模拟数据**编码为**数字信号
	- 计算机内部处理的是二进制，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现音频数字化）
	- 典型的例子
		- 对音频信号进行编码的脉码调制（PCM），在计算机应用中，能够达到最高保真水平的就是PCM编码。它的主要步骤包括三步：抽样、量化、编码
	- 抽样
		- 对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号
		- 为了使得所得到的离散信号能无失真地代表被抽样的模拟数据，要使采样定理进行采样：**f采样频率 ≥ 2f信号最高频率**
	- 量化：把抽样取得的电平幅值**按照一定的分级标度**转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量
	- 编码：把量化的结果转换为与之对应的二进制编码
- 模拟数据**调制为**模拟信号
	- 在模拟信号传输过程中，可能信道的长度非常长，环境比较恶劣，会导致传输的模拟信号会受到衰减
	- 为了保证传输的有效性，需要将信号调制成频率更高的信号来应对传输过程的衰减
    - 接收方接收到调制的信号后，通过**解调器**将信号还原为原来的信号

**王道习题：**

一轮标记题：1 3 4 9 10 17 18 20 25 29 33 36

二轮重做：9 16 17 18 25 41

大题：2 4 5(答案都看不懂！)
1.
- 答：分组交换生成的PDU的长度较短且是固定的，而报文交换生成的PDU的长度不是固定的。正是这一差别使得分组交换具有独特的优点：①缓冲区易于管理；②分组的平均延迟更小，网络中占用的平均缓冲区更少；③更易标准化；④更适合应用。因此，现在的主流网络基本上都可视为分组交换网络

2.
- 1) 2.57s
- 2) 32MB
- 3) 它表示发送方在收到一个响应之前能够发送的数据量
- 4) 在图像可以开始到达地面之前，至少需要一个RTT。假定仅有带宽延迟，那么发送需要的时间等于25MB/(100Mb/s)=(25×1024×1024×8)bit/(100Mb/s)≈2.1s。因此，直到最后一个图像位到达地球，总共花的时间等于2.1+2.57=4.67s

3.
- 1) (10000b / 10Mb/s) * 2 + 20μs * 2 + 35μs = 2075μs
- 2) 10000b / 10Mb/s + 5000b / 10Mb/s + 20μs * 2 + 35μs = 1575μs

4.
- 解：每部电话平均每小时通话次数=4/8=0.5次，每次通话6分钟，因此一部电话每小时占用一条电路3分钟，即20部电话可共享一条线路。**由于只有10%的呼叫是长途，因此200部电话占用一条完全时间的长途线路。**局间干线复用了10^6/(4×10)=250条线路，每条线路支持200部电话，因此一个端局能支持的最大电话数是200×250=50000部

5.
- 解：由于每个话路采用7bit编码，然后再加上1bit信令码元，因此一个话路占用8bit。帧同步码是在24路的编码之后加上1bit，因此每帧有8bit×24 + 1bit = 193bit。因为每秒采样8000次，因此采样频率为8000Hz，即采样周期为1/8000s = 125μs。所以T1的数据率为193bit/(125×10^-6s)= 1.544Mb/s

6.
- 解：
    - 整个传输过程的总时延 = 连接建立时延 + 源点发送时延 + 中间结点的发送时延 + 中间结点的处理时延 + 传播时延
    - 源点要将L位的报文分割成分组，分组数 = L/p，每个分组的长度为(h+p)，源点要发送的数据量 = (h+p)L/p，所以源点的发送时延 = (h+p)L/(pb)秒
    - 每个中间结点的发送时延 = (h+p)/b秒，源点和终点之间的线路数为k，所以有k-1个中间结点，因此中间结点的发送时延 = (h + p)(k - 1)/b秒
    - 中间结点的处理时延 = m(k-1)秒，传播时延 = kd秒。
    - 所以源结点开始发送数据直至终点收到全部数据所需要的时间= s +(h +p)L/(pb)+(h+ p)(k- 1)/b + m(k- 1)+ kd秒。

错题总结：
- 注意区分「采样频率」和「信道频率」
- 不同的数据交换方式有不同的性能。为了使数据在网络中的传输时延最小，首选的交换方式是电路交换；为保证数据无差错地传送，不应选用的交换方式是电路交换；在出错率很高的传输系统中，选用数据报方式更合适
- 电路交换是真正的物理线路交换，例如电话线路；**虚电路交换是多路复用技术，每条物理线路可以进行多条逻辑上的连接**。虚电路不只是临时性的，它提供的服务包括永久性虚电路(PVC)和交换型虚电路(SVC)，其中前者是一种提前定义好的、基本上不需要任何建立时间的端点之间的连接，而后者是端点之间的一种临时性连接，这些连接只持续所需的时间，并且在会话结束时就取消这种连接。数据报服务是无连接的，不提供可靠性保障，也不保证分组的有序到达。
- 虚电路服务需要有建立连接的过程，每个分组使用短的虚电路号，属于同一条虚电路的分组按照同一路由进行转发，分组到达终点的顺序与发送顺序相同，可以保证有序传输，不需要为每条虚电路预分配带宽

#### (3)传输介质及其特性

定义：
- 传输介质也称传输媒体，它是数据传输系统中发送设备和接收设备之间的物理通路
- 传输信息所利用的一些传输媒体，如双绞线、光缆、无线信道等，**并不在物理层协议之内而在物理层协议之下**，因此有人将物理媒体称作第0层（物理层规定了电气特性，所以能识别所传送的是比特流。）
- 传输介质可以分为：导向性传输介质和非导向性传输介质
    - 导向性传输介质：铜线，光纤
    - 非导向性传输媒介质：空气，真空，海水

双绞线：
- 把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来。绞合可减少对相邻导线的电磁干扰
- 双绞线的带宽取决于铜线的粗细和传输的距离
- 非屏蔽双绞线UTP：无屏蔽层的双绞线
- 屏蔽双绞线STP：为了提高双绞线抗电磁干扰的能力，可以在双绞线的外面再加上一层用金属丝编织成的屏蔽层
- 优缺点：价格便宜，通信距离短，长距离的模拟传输需要放大器放大衰减信号，对于数字传输则要用**中继器**将失真的信号整形

同轴电缆：
- 同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、**网状编织的外导体屏蔽层**（也可以是单股的）以及保护塑料外层所组成
- 基带同轴电缆：传送基带数字信号，用于局域网
- 带宽同轴电缆：传送宽带信号，用于有线电视系统
- 优缺点：由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据，其传输距离比双绞线更远，价格也更高

光纤：
- 光纤通信就是利用光导纤维（以下简称为光纤）传递光脉冲来进行通信。有光脉冲相当于1，而没有光脉冲相当于0
- 特点：
	- 传输损耗小，中继距离长，对远距离传输特别经济。
	- 抗雷电和电磁干扰性能好。
	- 无串音干扰，保密性好，也不易被窃听或截取数据。
	- 体积小，重量轻。
- 分类：
名称|定义|光源|特点
:-:|-|-|-
单模光纤|一种在**横向模式**直接传输光信号的光纤|定向性很好的激光二极管|**衰耗小**，适合远距离传输
多模光纤|有**多种**传输光信号模式的光纤|发光二极管|**易失真**，适合近距离传输

联动：
- 10BASE-T是传送**基带信号**的**双绞线以太网**，**T表示采用双绞线**，现10BASE-T采用的是**无屏蔽双绞线(UTP)**，传输速率是10Mb/s。物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m，采用**曼彻斯特编码**，采用CSMA/CD介质访问控制

**王道习题：**

一轮标记题：1 3 4 7

二轮重做：7 9~12

错题总结：
- 传统以太网采用广播的方式发送信息，同一时间只允许一台主机发送信息，否则各主机之间就会形成冲突，因此主机间的通信方式是半双工
- 同轴电缆比双绞线的传输速率更快，得益于其高屏蔽性，从而既有很高的带宽，又有很好的抗噪性
- **光纤的直径减小到与光线的一个波长相同时，光纤就如同一个波导，光在其中没有反射，而沿直线传播，这就是单模光纤**

#### (4)信道复用技术

#### (5)数字传输系统

#### (6)宽带接入技术

#### (7)其他

电路交换、报文交换与分组交换：
- 电路交换：需要建立一条专用的数据通信路径，这条路径上可能包含许多中间节点。这条通信路径在整个通信过程中将被独占，直到通信结束才会释放资源。电路交换**适合实时性要求较高的大量数据传输的情况**
- 报文交换（注意，此处的“报文”与UDP中的“报文”不是同一个意思！）：以报文作为数据传输单位，携带有源地址和目的地址等信息。报文交换主要使用在早期的电报通信网中，现在较少使用，通常被较先进的分组交换方式所取代
- 分组交换：分组交换根据其通信子网向端点系统提供的服务，**还可进一步分为面向连接的虚电路方式和无连接的数据报方式**。这两种服务方式都由**网络层**提供。要注意数据报方式和虚电路方式是分组交换的两种方式

特点|数据报服务|虚电路服务
-|-|-
连接的建立|不需要建立网络层连接|必须建立**网络层**连接
携带信息|每个分组在传输过程中都要携带源地址和目的地址|分组**只需要携带虚电路标识**
目的地址|每个分组都有完整的目的地址|**仅在建立连接阶段使用**，之后每个分组使用长度较短的虚电路号
路由选择|每个分组独立地进行路由选择和转发|属于同一条虚电路的分组按照同一路由转发
分组顺序|不保证分组的有序到达|保证分组的有序到达
可靠性|不保证可靠通信，**可靠通信应当由用户主机来保证**|**可靠通信应当由网络来保证**
对网络故障的适用性|出故障的节点丢失分组，其他分组路径选择发生变化时可正常传输|**所有经过故障节点的虚电路均不能正常工作**
差错处理和流量控制|由用户主机进行流量控制，不保证数据报的可靠性|**可由分组交换网负责，也可由用户主机负责**

#### 本章小结

什么是基带传输、频带传输和宽带传输?三者的区别是什么?
- 基带传输（数据→数字）：通常用于**局域网**；常用的编码方法有不归零编码和曼彻斯特编码
- 频带传输（数据→模拟）：用数字信号对特定频率的载波进行调制（数字调制)，将其变成适合于传送的信号后再进行传输，这种传输方式就是频带传输。远距离传输或无线传输时，数字信号必须用频带传输技术进行传输。利用频带传输，不仅解决了电话系统传输数字信号的问题，而且可以实现多路复用，进而提高传输信道的利用率。同样传输1010，经过调制，一个码元对应4个二进制位，假设码元A代表1010，那么在模拟信道上传输码元A就相当于传输了1010，这就是频带传输。**借助频带传输，可将链路容量分解成两个或多个信道，每个信道可以携带不同的信号，这就是宽带传输。**宽带传输中所有的信道能同时互不干扰地发送信号，链路容量大大增加。比如把信道进行频分复用，划分为2条互不相关的子信道，分别在两条子信道上同时进行频带传输，链路容量就大大增加了，这就是宽带传输

什么是同步通信和异步通信？
- 同步通信的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地发送和接收连续的同步比特流。主要有两种同步方式：一种是全网同步，即用一个非常精确的主时钟对全网所有结点上的时钟进行同步；另一种是准同步，即各结点的时钟之间允许有微小的误差，然后采用其他措施实现同步传输。**同步通信数据率较高，但实现的代价也较高**
- 异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的，但接收端必须时刻做好接收的准备。发送端可以在任意时刻开始发送字符，因此必须在每个字符开始和结束的地方加上标志，即开始位和停止位，以便使接收端能够正确地将每个字符接收下来。异步通信也可以帧作为发送的单位。这时，帧的首部和尾部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始（即帧定界）。**异步通信的通信设备简单、便宜，但传输效率较低（因为标志的开销所占比例较大)**

如何提高信息传输速率？
- 要么设法提高传输线路的带宽，要么设法提高所传信道的信噪比，此外没有其他任何办法

### <a name="19">（三）数据链路层</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

#### (1)数据链路层功能和设计要点

#### (2)错误检测和纠正

#### (3)基本数据链路协议，包括：停止-等待协议、后退N帧协议和选择重传协议；

#### (4)滑动窗口协议

#### (5)点对点协议PPP

#### (6)介质访问控制协议，包括介质访问控制基本概念、协议分类、CSMA/CD协议；

#### (7)以太网，包括MAC地址、IEEE局域网标准、以太网、高速以太网技术；

#### (8)局域网互连技术，包括物理层及数据链路层互连技术、网桥概念和工作原理、局域网交换机工作原理；

#### (9)无线局域网(IEEE802.11)基本知识，包括CSMA/CA协议原理等。

## <a name="23">附录：各种名词缩写及含义</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

**计算机组成原理：**

英文|缩写|补充说明
:-:|:-:|-
Central Processing Unit|CPU|略
Memory Address Register|MAR|地址寄存器
Memory Data Register|MAR|数据寄存器
Clock cycle Per Instruction|CPI|执行每条指令所需的平均时钟周期数
Million Instructions Per Second|MIPS|每秒执行多少百万条指令数量
Mega Floating-Point Operations Per Second|MFLOPS|每秒执行多少百万条指令数量
Arithmetic Logic Unit|ALU|算术逻辑单元

**操作系统：**

英文|缩写|补充说明
:-:|:-:|-
Basic Input Output System|BIOS|一组固化到计算机内主板上一个ROM芯片上的程序，保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序
Process Control Block|PCB|使参与并发执行的每个程序（含数据）能够独立运行的专门的数据结构
Thread Control Block|TCB|线程控制块
User-Level Thread|ULT|用户级线程
Kernel-Level Thread|KLT|内核级线程
First Come First Serve|FCFS|先来先服务
Shortest Job First|SJF|短进程优先
Round-Robin|RR|轮询调度

**计算机网络：**

英文|缩写|补充说明
:-:|:-:|-
Wide Area Network|WAN|广域网
Metropolitan Area Network|MAN|城域网
Local Area Network|LAN|局域网
Personal Area Network|PAN|个人区域网
Round-Trip Time|RTT|往返时延
Service Data Unit|SDU|服务数据单元，物理层的服务数据单元就是1-SDU
Protocol Control Information|PCI|控制协议操作的信息，链路层的协议控制信息就是2-PCI
Protocol Data Unit|PDU|对等层次之间传送的数据单位称为该层的PDU，物理层的PDU称为比特流，数据链路层的称为帧，网络层为分组/IP数据报，传输层为报文段
Service Access Point|SAP|逻辑接口，是一个层次系统的上下层之间进行通信的接口，和硬件接口有所不同
International Standardization Organization|ISO|国际标准化组织
Open System Interconnection reference model|OSI/RM|开放系统互连参考模型
Return to zero|RZ|归零编码
Non return to zero|NRZ|非归零编码
Non return to zero, inverted|NRZI|反向非归零编码
Amplitude Shift Keying|ASK|幅移键控
Frequency Shift Keying|FSK|频移键控
Phase Shift Keying|PSK|相移键控
Quadrature Amplitude Modulation|QAM|正交振幅调制
Pulse-Code Modulation|PCM|脉冲编码调制

**待收留：**

- 计算机组成原理
- 有符号时通常会将符号位累加在最低位后再进行算术右移

- 操作系统

- 计算机网络
- 典型的数据链路层协议有Ethernet、SDLC、HDLC、PPP、STP、帧中继等
- 网络层的协议有IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等
- 2.1.5 数据报&虚电路（网络层），有一个表格