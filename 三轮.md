# CS复习

## 模拟卷一

### 一：

1.浮点数运算练一下，为什么阶码部件在乘除运算时只进行加减操作？

2.**采用随机存取方式的存储器 ≠ 随机存储器**

5.总线选择题

9.PV练一下

11.物理层：采样？选择题复习

12.链路层选择题

15.应用层选择题

### 二：

1.总线分类

4.
    指令执行所用到的元件有两类：组合逻辑元件（也称为操作元件）和存储元件（也称状态元件）
    连接这两类元件的方式：总线方式和分散连接方式
    数据通路就是由操作元件和存储元件通过总线或分散方式连接而成的进行数据存储，处理和传送的路径
    1.**组合逻辑元件**（只取决于当前的输入）
    一般由多路选择器（MUX），加法器（Adder），算数逻辑部件（ALU），译码器（Decoder）
    2.**状态元件**（最常见的就是D触发器）
    ————————————————
    版权声明：本文为CSDN博主「Julia_luofang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/weixin_43978453/article/details/102653972

10.OSI的层次结构

### 三：CPI和MIPS还会算吗？

### 五：💎牢记：

页表项的构成：页号 + 页帧号 + 状态位P + 访问字段A + 修改位M + 外存地址L

状态位/合法位P：标记该页是否已被调入内存中 → 供程序访问时参考，用于判断是否触发缺页异常

访问字段A：记录本页在一段时间内被访问的次数 → 供置换算法换出页面时参考

修改位M：标识该页在调入内存后是否被修改过 → 当页面被淘汰时，若页面数据没有修改，则不用写回外存

外存地址L：用于指出该页在外存上的地址，通常是物理块号 → 供写回外存和从外存中调入此页时参考

对比：Cache行的构成 = 状态位 + 主存块地址tag + 数据块副本 + 脏位/修改位 + 置换标记位/访问字段，三处相同，页表项的页号 + 页帧号与Cache的tag等效

### 六：

💎复习要求：

会默写常见MIPS指令（一表，32条）

知道常见控制信号，能梳理清楚多周期的数据通路（一图）

### 九：

页表项？段表项？段页表呢？

### 十：

文件的物理结构？

### 十一：

记忆一下专用IP、特殊IP

路由表有哪几项？

路由算法？

## 模拟卷二

### 一：

1.浮点数

5.总线带宽

9.程序装入与链接

12.CSMA/CD

15.SMTP

### 二：
1.

主存容量 / Cache容量 = 标记项位数

主存单元号（字块号） / 组相联路数 = 组号

9.数据链路层的三个重要问题

10.电子邮件涉及协议（应用层协议及端口记忆）

### 五：

面向运算的i型指令：addi；andi；ori；xori。第一条指令是进行符号扩展，其余是0扩展

### 六：💎

slt (set less than)

slti(set less than immediate)

跳转指令（j）：**PC高4位，接上（不是加上！）立即数26位，低2位为0**，最大跳转到0x0f ff ff fc

分支指令（i）：

Largest Positive Displacement: 0x0001FFFC（15个1左移两位）

Largest Negative Displacement: 0xFFFE0000（符号扩展的FFFF8000左移两位）

### 七：

库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常要比系统调用的高，因为使用系统调用时，需要上下文的切换及状态的切换（也就是由用户态转向核心态）

### 八：

P：使用 / 申请 / 等待
V：返还 / 通知

```
int waiting = 0;
semaphore mutex = 1;
semaphore bchair = 1;
semaphore cchair = 5;
semaphore ready = 0;
semaphore finish = 0;
semaphore up = 0;
cobegin{
    void Customer(){
        P(mutex);
        if(waiting >= 6){
            V(mutex);
            return();
        }
        if(waiting == 0) V(up);
        waiting ++;
        V(mutex);

        P(cchair); //使用一个顾客椅子
        P(bchair); //申请一个理发师椅子
        V(cchair); //返还一个顾客椅子

        V(ready);
        被理发;
        P(finish);

        V(bchair); //返还一个理发师椅子

        P(mutex);
        waiting--;
        V(mutex);
    }
    void Barber(){
        while(1){
            P(mutex);
            if(waiting == 0){
                V(mutex); // 立即释放，否则造成死锁！！
                P(bchair);
                P(up);
                V(bchair);
            }else
                V(mutex);
            P(ready);
            理发;
            V(finish);
        }
    }
}
coend
```

